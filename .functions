# Create a new directory and enter it
unalias md 2>/dev/null
md() {
  mkdir -p "$@" && cd "$@"
}

# Easier navigation: .., ..., etc.
unalias .. 2>/dev/null
..() {
  eval cd ../\""$@"\"
}

_..() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ..* ]] || COMP_WORDS[COMP_CWORD]="../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b1-3 --complement) )
}
complete -o nospace -F _.. ..

unalias ... 2>/dev/null
...() {
  eval cd ../../\""$@"\"
}

_...() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ../..* ]] || COMP_WORDS[COMP_CWORD]="../../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b1-6 --complement) )
}
complete -o nospace -F _... ...

unalias .... 2>/dev/null
....() {
  eval cd ../../../\""$@"\"
}

_....() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ../../..* ]] || COMP_WORDS[COMP_CWORD]="../../../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b1-9 --complement) )
}
complete -o nospace -F _.... ....

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
httpcompression() {
  encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

function my_cd {
    \cd "$@" >/dev/null
}
alias cd='my_cd'
complete -o nospace -F _cd my_cd

# All the dig info
digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

a() {
  ack "$@" .
}

mpcategory() {
  port info $@ 2>/dev/null | head -n 1 | sed -n 's#.*(\(.\{1,\}\)).*#\1#p' | awk -F',' '{print $1}'
}

mpc() {
  local CATEGORY=$(mpcategory $@)
  [[ -n $CATEGORY ]] && echo "$MP/$CATEGORY"
}

mp() {
  local CATEGORY=$(mpcategory $@)
  local MPFILE=$MP/$CATEGORY/$@
  if [ -e $MPFILE ]; then
    echo "$MPFILE"
  else
    echo "file not found: $MPFILE" 1>&2
  fi
}

mpe() {
  local MPFILE=$(port file $@)
  [ -e $MPFILE ] && e $MPFILE
}

mpdiff() {
  local MPFILE=$(mp $@)/Portfile
  [ -e $MPFILE ] && opendiff $MPFILE $(port file $@)
}

mpcp() {
  local MPFILE=$(mp $@)
  if [ -d $MPFILE ]; then
    local CATEGORY=$(mpcategory $@)
    [ ! -d $CATEGORY ] && mkdir $CATEGORY
    [ ! -d $CATEGORY/$@ ] && mkdir $CATEGORY/$@
    cp -R $MPFILE/* $CATEGORY/$@
  fi
}

mpls() {
  local MPFILE=$(mp $@)
  if [ -d $MPFILE ]; then
    echo "Port: $MPFILE"
    ls $MPFILE
  fi
}

mpbumprev() {
  for f in $@; do
    perl -i -pe 's#(^revision\s+)([0-9.]+)#"$1" . ($2 + 1)#e;' $f
  done
}

psgrep() {
  ps aux | grep -v grep | grep "$@"
}

killgrep() {
  local PROCS=$(psgrep $@ | awk '{print $2;}')
  for p in $PROCS; do
    kill $p
  done
}

d() {
  local GET="curl -O"
  [[ -z "$(which curl 2>/dev/null)" ]] && GET="wget -c"

  for i in $@; do
    $GET $i;
  done;
}

essh() {
  # system ssh command
  local SSH=$(which ssh)

  # read from emacs server file what port it is currently listening on
  local PORT=$(egrep  -o '127.0.0.1:([0-9]*)' ~/.emacs.d/server/server | sed 's/127.0.0.1://')

  # read the server file, escaping single quotes that are in the auth string
  local SRV=$(cat ~/.emacs.d/server/server | sed "s/'/\\\\\\'/")

  # When connecting to the remote host, print the server file to the
  # correct location and then invoke my shell.
  local CMD="mkdir -m 700 -p ~/.emacs.d/server; echo $'$SRV' > ~/.emacs.d/server/server; bash -l"

  # -t : allocate a tty so we are there.
  # -R : the remote port forward that lets emacsclient talk back
  # $@ : any other args this script was invoked with should be passed along.
  $SSH -t -R $PORT:127.0.0.1:$PORT $@ "$CMD"
}
complete -F _ssh essh

pd() {
  local d="${@%/}"
  if [ ! -z "$d" ]; then
    if [ ! -d "$d" ]; then
      for i in ${CDPATH//:/$'\n'}; do [ -d "$i/$d" ] && d="$i/$d"; done
    fi
    [ -d "$d" ] && export PETSC_DIR="$(readlink -f $d)" || echo "error: $d is not a directory"
  fi
  echo "$PETSC_DIR"
}
complete -o nospace -F _cd pd

_reverse_list() {
  echo $(echo $@ | awk '{for (i = NF; i > 0; i--){print $i}}')
}

# this assumes only one compile type (e.g. gcc46 XOR clang XOR gcc45)
# it also fixes the type of variants (e.g. +debug, +longindex)
_build_port_list() {
  local list=""
  local cmd="printf @ && port installed \$i | sed -n 2p | cut -d'@' -f2 | sed 's, (active),,' | sed 's,\+debug,,' | sed 's,\+longindex,,'"
  local variants="$3"

  [[ $2 == *-test* ]] && variants="" && cmd=""

  for i in $1; do
    list="$list $i$(eval $cmd)$variants"
  done

  echo $list
}

# very simple for now, only +debug and +longindex
_activate_pa() {
  if [ -x /opt/local/bin/port ]; then
    local ports="hdf5-18 netcdf ml hypre blacs scalapack mumps superlu sundials suitesparse fftw-3 fftw-3-single fftw-3-long"
    local ports64="metis parmetis superlu_dist" # which just *happens* to also be the dependencies
    local debug=""
    local long=""
    local command="activate"
    local p=""
    local list="$ports64"

    [[ $PETSC_ARCH != *-opt* ]] && debug="+debug"
    [[ $PETSC_ARCH == *-64* ]] && long="+longindex"

    local variants="$debug$long"

    [[ $PETSC_ARCH == *-test* ]] && command="deactivate" && list="$(_reverse_list $ports)" && variants="$debug"

    p=$(_build_port_list "$list" $PETSC_ARCH "$variants")

    list="$ports"
    variants="$debug"
    [[ $PETSC_ARCH == *-test* ]] && list="$(_reverse_list $ports64)" && variants="$debug$long"

    p=$p\ $(_build_port_list "$list" $PETSC_ARCH "$variants")

    for i in $p; do sudo port $command $i; done
  fi
}

pa() {
  [ ! -z "$@" ] && export PETSC_ARCH="arch-${@%/}" && _activate_pa
  echo "$PETSC_ARCH"
}
complete -W "c c-64 c-fast c-opt complex cuda intel intel-opt" pa

rmlog() {
  rm -rf CMake* *.log *.log.* *TAGS *.cache *.status $@
}
complete -A file rmlog

prm() {
  rm -rf arch* externalpackages && rmlog $@
}
complete -A file petsc-clean

pc() {
  printf "Configuring for PETSC_ARCH: "

  local extra=""
  local arch=""
  for opt in $@; do
    [[ $opt == --* ]] && extra="$extra $opt" || arch="$opt"
  done

  pa $arch
  arch="$PETSC_ARCH"
  local common="netcdf,ml,hypre,metis,parmetis,blacs,scalapack,mumps,superlu,superlu_dist,sundials,umfpack,cholmod,fftw,yaml,numdiff"
  local libs="--with-shared-libraries --with-c++-support --COPFLAGS=-O0 --CXXOPTFLAGS=-O0 --FOPTFLAGS=-O0"

  if [[ $PETSC_ARCH == *-64* ]]; then
    common="metis,parmetis,superlu_dist,numdiff"
    libs="$libs --with-64-bit-indices"
  fi

  [[ $PETSC_ARCH == *-cuda* ]] && libs="$libs --with-cusp-dir=/opt/local --with-thrust --with-cuda"

  libs="--with-{$common}-dir=/opt/local $libs"
  [[ $PETSC_ARCH == *-test* ]] && libs=""

  eval ./configure $extra $libs
}
