# Create a new directory and enter it
unalias md 2>/dev/null
md() {
  mkdir -p "$@" && cd "$@"
}

# Easier navigation: .., ..., etc.
unalias .. 2>/dev/null
..() {
  eval cd ../\""$@"\"
}

_..() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ..* ]] || COMP_WORDS[COMP_CWORD]="../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b4- ) )
}
complete -o nospace -F _.. ..

unalias ... 2>/dev/null
...() {
  eval cd ../../\""$@"\"
}

_...() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ../..* ]] || COMP_WORDS[COMP_CWORD]="../../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b7- ) )
}
complete -o nospace -F _... ...

unalias .... 2>/dev/null
....() {
  eval cd ../../../\""$@"\"
}

_....() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ../../..* ]] || COMP_WORDS[COMP_CWORD]="../../../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b9- ) )
}
complete -o nospace -F _.... ....

function my_cd {
    \cd "$@" >/dev/null
}
alias cd='my_cd'
complete -o nospace -F _cd my_cd

##################
# helper functions
##################

# usage: _not_in_list_exit $element $list
# return: echo "1" if found, "" if not found
_in_list() {
  local i
  local found=0

  for i in ${2//,/ }; do [[ "$i" == "$1" ]] && found=1; done

  [ $found -eq 1 ] && echo 1
}

# All the dig info
digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

killgrep() {
  local PROCS=$(psgrep $@ | grep $USER | awk '{print $2;}')
  for p in $PROCS; do
    kill -9 $p
  done
}

d() {
  local i
  local GET="curl -O"
  [[ -z "$(which curl 2>/dev/null)" ]] && GET="wget -c"

  for i in $@; do
    $GET $i;
  done;
}

essh() {
  # system ssh command
  local SSH=$(which ssh)

  # read from emacs server file what port it is currently listening on
  local PORT=$(egrep  -o '127.0.0.1:([0-9]*)' ~/.emacs.d/server/server | sed 's/127.0.0.1://')

  # read the server file, escaping single quotes that are in the auth string
  local SRV=$(cat ~/.emacs.d/server/server | sed "s/'/\\\\\\'/")

  # When connecting to the remote host, print the server file to the
  # correct location and then invoke my shell.
  local CMD="mkdir -m 700 -p ~/.emacs.d/server; echo $'$SRV' > ~/.emacs.d/server/server; bash -l"

  # -t : allocate a tty so we are there.
  # -R : the remote port forward that lets emacsclient talk back
  # $@ : any other args this script was invoked with should be passed along.
  $SSH -t -R $PORT:127.0.0.1:$PORT $@ "$CMD"
}
complete -F _ssh essh

psgrep() {
  ps aux | grep -v grep | grep "$@"
}

mpcategory() {
  port info $@ 2>/dev/null | head -n 1 | sed -n 's#.*(\(.\{1,\}\)).*#\1#p' | awk -F',' '{print $1}'
}

mpc() {
  local CATEGORY=$(mpcategory $@)
  [[ -n $CATEGORY ]] && echo "$MP/$CATEGORY"
}

mp() {
  local CATEGORY=$(mpcategory $@)
  local MPFILE=$MP/$CATEGORY/$@
  if [ -e $MPFILE ]; then
    echo "$MPFILE"
  else
    echo "file not found: $MPFILE" 1>&2
  fi
}

_mpe() {
  local cur prev words cword codesearch
  _init_completion || return
  codesearch=$(which csearch)

  if [ -z "$codesearch" ]; then
    COMPREPLY=( $( command port -q search --name --glob -- "$cur*" 2>/dev/null | uniq ) )
  else
    COMPREPLY=( $( command csearch -f Portfile ^name\\s+"$cur".* | awk -F':' '{print $1}' | xargs dirname 2>/dev/null | xargs -I{} basename {} 2>/dev/null ) )
  fi
}

mpdiff() {
  local MPFILE=$(mp $@)/Portfile
  [ -e $MPFILE ] && diff -u $MPFILE $(port file $@)
}
complete -F _mpe mpdiff

mpopendiff() {
  local MPFILE=$(mp $@)/Portfile
  [ -e $MPFILE ] && opendiff $MPFILE $(port file $@)
}
complete -F _mpe mpopendiff

mpcp() {
  local MPFILE=$(mp $@)
  if [ -d $MPFILE ]; then
    local CATEGORY=$(mpcategory $@)
    [ ! -d $CATEGORY ] && mkdir $CATEGORY
    [ ! -d $CATEGORY/$@ ] && mkdir $CATEGORY/$@
    cp -R $MPFILE/* $CATEGORY/$@
    hg add $CATEGORY/$@
    hg ci $CATEGORY/$@ -m"$@: copy from macports"
  fi
}
complete -F _mpe mpcp

mpls() {
  local MPFILE=$(mp $@)
  if [ -d $MPFILE ]; then
    echo "Port: $MPFILE"
    ls $MPFILE
  fi
}
complete -F _mpe mpls

mpbumprev() {
  for f in $@; do
    perl -i -pe 's#(^revision\s+)([0-9.]+)#"$1" . ($2 + 1)#e;' $f
  done
}

_mp_compilers() {
  local c=$(echo clang{,3{0..2}} gcc4{4..8} dragonegg3{0..2} system_gcc)
  echo ${c//\ /,}
}

_mp_mpis() {
  local m=$(echo {mpich2,openmpi}{-devel,})
  echo ${m//\ /,}
}

mpmpi() {
  local i port variant

  local compilers=$(_mp_compilers)
  local mpis=$(_mp_mpis)
  local mpisvariants="${mpis//-/_}"

  local portquery=$(port installed ${mpis//,/\ } | grep active)
  local olddebug=$(echo $portquery | perl -lne "print $& if /\+(debug)/" | perl -pe 's,\+,,g')
  local oldmpi=$(echo $portquery | perl -lne "print $& if /(${mpis//,/|})/")
  local oldc=$(echo $portquery | perl -lne "print $& if /(${compilers//,/|})/")

  if [ $# -eq 0 ]; then
    echo "$oldmpi/$oldc $olddebug"
    return 0
  fi

  local mpi=$(echo $1 | cut -d/ -f1)
  local c=$(echo $1 | cut -d/ -f2)

  [ ! $(_in_list "$mpi" "$mpis") ] && echo "$mpi is not in the list of $mpis" && return 1
  [ ! $(_in_list "$c" "$compilers") ] && echo "$c is not in the list of $compilers" && return 1

  local deps=$($HOME/.port-rdependents.py $oldmpi $oldc)

  local OLD_IFS=$IFS
  IFS=$'\n';

  rm -f ~/.ports.undo.deactivate.$oldmpi.$oldc

  for i in $deps; do
    port=$(echo $i | cut -d' ' -f1)
    variant=$(echo $i | cut -d' ' -f2)

    echo "port -q activate $port $variant" >> ~/.ports.undo.deactivate.$oldmpi.$oldc
    sudo port -q deactivate $port
  done

  [[ "$deps" != "$oldmpi" ]] && rm -f ~/.ports.undo.install.$mpi.$c

  for i in $(printf "$deps\n" | tac); do
    port=$(echo $i | cut -d' ' -f1)
    variant=$(echo $i | cut -d' ' -f2)

    # some hacky logic; if $2 is non-empty and contains:
    #   opt) debug -> opt
    #   debug) opt -> debug
    [[ "$port" == "$oldmpi" ]] && port=$mpi
    [[ "$port*" == "openmpi-devel*" ]] && variant="$variant+threads+valgrind"
    [[ "$2" == "debug" ]] && variant=$(echo "$variant" | perl -pe 's,\-debug,+debug,' | perl -pe 's,\+opt,,g' | perl -pe 's,\+tuned,,g')
    [[ "$2" == "opt" ]] && variant=$(echo "$variant+opt+tuned" | perl -pe 's,\+debug,-debug,')

    variant=$(echo $variant | perl -pe "s,${compilers//,/|},$c,g")
    variant=$(echo $variant | perl -pe "s,${mpisvariants//,/|},${mpi//-/_},g")

    echo "port -q clean $port" >> ~/.ports.undo.install.$mpi.$c
    echo "port -q install $port $variant" >> ~/.ports.undo.install.$mpi.$c
  done

  IFS=$OLD_IFS

  sudo ~/.sudo-batch.sh ~/.ports.undo.install.$mpi.$c

  [ $? -eq 0 ] && rm -f ~/.ports.undo.install.$mpi.$c && rm ~/.ports.undo.deactivate.$oldmpi.$oldc
}
complete -W "$(echo {$(_mp_mpis)}/{$(_mp_compilers)})" mpmpi

pd() {
  local i
  local d="${@%/}"
  if [ ! -z "$d" ]; then
    if [ ! -d "$d" ]; then
      for i in ${CDPATH//:/$'\n'}; do [ -d "$i/$d" ] && d="$i/$d"; done
    fi
    [ -d "$d" ] && export PETSC_DIR="$(readlink -f $d)" || echo "error: $d is not a directory"
  fi
  echo "$PETSC_DIR"
}
complete -o nospace -F _cd pd

# this enforces only one compiler type (e.g. gcc46 XOR clang XOR gcc45)
_build_port_list() {
  local i
  local list=""
  local cmd="printf @ && port installed \$i | sed -n 2p | cut -d'@' -f2 | sed 's, (active),,' | sed 's,\+debug,,' | sed 's,\+longindex,,'"
  local variants="$3"

  [[ $2 == *-test* ]] && variants="" && cmd=""

  for i in $1; do
    list="$list $i$(eval $cmd)$variants"
  done

  echo $list
}

# very simple for now, only +debug and +longindex
_activate_pa() {
  [ ! -x /opt/local/bin/port ] && return

  local i
  local ports="$(port -q rdependents mpich2 | s 's,^\s+,,' | tac)"
  local ports64="metis parmetis superlu_dist" # which just *happens* to also be the dependencies
  local debug=""
  local long=""
  local command="activate"
  local p=""
  local list="$ports64"
  local compilers="$(echo clang{,3{0..2}} gcc4{4..8} dragonegg3{0..2} llvm system_gcc)"
  local mpis="$(echo {mpich2,openmpi}{-devel,})"
  local compiler=$(port installed $mpis | grep active | perl -lne "print $& if /(${compilers//\ /|})/")
  local mpi=$(port installed $mpis | grep active | perl -lne "print $& if /(${mpis//\ /|})/")

  echo "DEBUG: compiler=$compiler"
  echo "DEBUG: mpi=$mpi"

return 0

  [[ $PETSC_ARCH != *-opt* ]] && debug="+debug"
  [[ $PETSC_ARCH == *-64* ]] && long="+longindex"

  local variants="$debug$long"

  [[ $PETSC_ARCH == *-test* ]] && command="deactivate" && list="$(_reverse_list $ports)" && variants="$debug"

  p=$(_build_port_list "$list" $PETSC_ARCH "$variants")

  list="$ports"
  variants="$debug"
  [[ $PETSC_ARCH == *-test* ]] && list="$(_reverse_list $ports64)" && variants="$debug$long"

  p=$p\ $(_build_port_list "$list" $PETSC_ARCH "$variants")

  for i in $p; do sudo port $command $i; done
}

pa() {
  [ ! -z "$@" ] && export PETSC_ARCH="arch-${@%/}" && _activate_pa
  echo "$PETSC_ARCH"
}
complete -W "c c-64 c-fast c-opt complex cuda intel intel-opt" pa

rmlog() {
  rm -rf CMake* *.log *.log.* *TAGS *.cache *.status $@
}
complete -A file rmlog

prm() {
  rm -rf arch* externalpackages && rmlog $@
}
complete -A file petsc-clean

pc() {
  printf "Configuring for PETSC_ARCH: "

  local extra=""
  local arch=""
  for opt in $@; do
    [[ $opt == --* ]] && extra="$extra $opt" || arch="$opt"
  done

  pa $arch
  arch="$PETSC_ARCH"
  local common="netcdf,ml,hypre,metis,parmetis,blacs,scalapack,mumps,superlu,superlu_dist,sundials,umfpack,cholmod,fftw,yaml"
  local libs="--with-shared-libraries --with-c++-support --COPFLAGS=-O0 --CXXOPTFLAGS=-O0 --FOPTFLAGS=-O0"

  if [[ $PETSC_ARCH == *-64* ]]; then
    common="metis,parmetis,superlu_dist,numdiff"
    libs="$libs --with-64-bit-indices"
  fi

  [[ $PETSC_ARCH == *-cuda* ]] && common="$common,cusp" && libs="$libs --with-thrust --with-cuda"

  libs="--with-{$common}-dir=/opt/local $libs"
  [[ $PETSC_ARCH == *-test* ]] && libs=""

  eval ./configure $extra $libs
}

emacs-compile-plugins() {
  local i

  for i in $(ls | grep -v cedet); do
    if [ $(ls $i | grep -c elc) -eq 0 ]; then
      cd $i
      for j in *.el; do emacs -L . $(for i in ../*; do printf "%s" "-L $i "; done) -L ../nxhtml/util --batch --eval "(byte-compile-file \"$j\")"; done
      cd ..
    fi
  done
}
