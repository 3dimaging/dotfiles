#+TITLE: Emacs Configuration for Sean Farley
#+OPTIONS: ^:nil
#+PROPERTY: results silent
#+PROPERTY: eval no-export
#+PROPERTY: header-args :comments link

* Sean Farley's Emacs Configuration

** Preamble

As my editor of choice I run Emacs. One of the benefits of Emacs is
that it'll install basically anywhere.

This configuration is designed to run in shells as well as on
desktops. There are some platform specific optimisations as well.

This excellent configuration was forked from [[https://github.com/bradleywright/emacs.d][Bradley Wright]].

*** What is this?

It's built using [[http://orgmode.org][Org mode]]'s [[http://orgmode.org/manual/Extracting-source-code.html#Extracting-source-code][tangling functionality]].

My entire Emacs configuration is thus written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style,
and is contained entirely in this file.

*** Installing

Just check it out straight to the right directory, and use Make to
install it:

: cd ~/Projects/emacs.d && ./bootstrap

*** Included libraries

The following libraries are included in non-attributable ways, i.e not
via package install or via a Git submodule:

- [[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]] was a very big early influence, and continues to
  be helpful.

*** License and copyright

Copyright 2010 Bradley Wright.
Copyright 2014 Sean Farley.

Files are licensed under the same license as Emacs (GPL) unless
otherwise specified. See the =COPYING= file for more information.

Any external/third party works included in this work are licensed under
their own licenses - refer to the submodules or packages for more
information.

** Conventions

Functions and variables defined exclusively for my use are prefixed with my
initials and a slash =smf/= to namespace them.

** Setup

Emacs looks in [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Loading-Files.html][load-path]] for Emacs lisp files. =require= and other loading
constructs use this when looking for implicit names.

Before anything, let's bump the gc size to something bigger and more modern,

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 200000000)
#+END_SRC

First we define a convenience function =smf/add-to-load-path= that adds the
passed in directory to =load-path=:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-to-load-path (dir)
    "Adds `dir' to load-path"
    (add-to-list 'load-path dir))
#+END_SRC

and a convenience function for making a proper path out of two strings:

#+BEGIN_SRC emacs-lisp
  (defun smf/join-dirs (prefix suffix)
    "Joins `prefix' and `suffix' into a directory"
    (file-name-as-directory (concat prefix suffix)))
#+END_SRC

*** Base load path

Define a base directory =smf/dotfiles-dir= that's relative to the currently
loading file (this file). This means if I deliberately start Emacs with a file
loaded:

#+BEGIN_SRC
$ emacs -q -l ~/src/emacs/init.el
#+END_SRC

then =smf/dotfiles-dir= will be =~/src/emacs=.

#+BEGIN_SRC emacs-lisp
  (defconst smf/dotfiles-dir
    (file-name-directory
     (or (buffer-file-name) load-file-name))
    "Base path for customised Emacs configuration")
#+END_SRC

This variable is important because all other directories I load things from are
relative to it, which means my Emacs config doesn't need to live in
=user-emacs-directory=.

*** Temporary directory

Emacs has many packages which need to store state in files. Generally these are
in =~= or =user-emacs-directory= - since my entire =~/.emacs.d= is versioned,
I'd rather all temporary files were stored in a known place, =smf/tmp-local-dir=.
This directory is created if it doesn't exist.

#+BEGIN_SRC emacs-lisp
  (defvar smf/tmp-local-dir)
  (make-directory
   (setq smf/tmp-local-dir
         (smf/join-dirs smf/dotfiles-dir ".tmp")) t)
#+END_SRC

*** Backups

Emacs automatically [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Backup.html][backs up files]] while you're editing them. The default
configuration isn't great though.

First, set up some directories to keep backups:

#+BEGIN_SRC emacs-lisp
  (defvar smf/tmp-backups-dir)
  (defvar smf/tmp-autosaves-dir)
  (make-directory
   (setq smf/tmp-backups-dir
         (smf/join-dirs smf/tmp-local-dir "backups")) t)
  (make-directory
   (setq smf/tmp-autosaves-dir
         (smf/join-dirs smf/tmp-local-dir "autosaves")) t)
#+END_SRC

Now use those directories for backups and autosave files:

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `((".*" . ,smf/tmp-backups-dir))
        auto-save-file-name-transforms `((".*" ,smf/tmp-autosaves-dir)))
#+END_SRC

Always copy files when backing up to avoid breaking symlinks:

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t)
#+END_SRC

Delete old versions automatically, and keep a limited number around:

#+BEGIN_SRC emacs-lisp
  (setq delete-old-versions t
        kept-new-versions 2
        kept-old-versions 2)
#+END_SRC

Finally, use version numbers in the filenames:

#+BEGIN_SRC emacs-lisp
  (setq version-control t)
#+END_SRC

*** Launcher keymap

This trick I got from [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][a blog post on launcher keymaps]]. I define my launcher
combo as =C-x C-l=, which is normally =downcase-region= - a command I use so
infrequently I didn't even know there was a key binding for it.

#+BEGIN_SRC emacs-lisp
  (defvar smf/launcher-map)
  (define-prefix-command 'smf/launcher-map)
  (define-key ctl-x-map (kbd "C-l") 'smf/launcher-map)
#+END_SRC

rather than remembering that it's =smf/launcher-map=, just make a function:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-launcher (key function)
    "Maps FUNCTION to KEY under the `smf/launcher-map' prefix"
    (define-key smf/launcher-map key function))
#+END_SRC

** package manager

Emacs has a built-in [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging][package manager]].

Rather than using Git submodules or similar my Emacs configuration is set up to
automatically download and install any required packages at load time. This
makes my configuration fully portable.

*** Configure package manager

**** Custom package install location

The default value for =package-user-dir= is =~/.emacs.d/elpa= - since these are
third-party packages that are dynamically installed I'd prefer them to be in a
[[http://en.wikipedia.org/wiki/Dot-file][hidden directory]].

Packages are also [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][byte compiled]] upon installation, so namespace the install
directory to the version of Emacs I'm using.

Final result should be something like =~/.emacs.d/.elpa/24.3.93.1/=.

**** Ensure package list is refereshed

#+BEGIN_SRC emacs-lisp
  ;; Set the initial state to non-refreshed. This can also be set back
  ;; to nil if we want to run a refresh on the next install.
  (defvar smf/refreshed-package-list nil)

  (defun smf/ensure-refreshed ()
    "Ensure the package list has been refreshed this startup."
    (unless smf/refreshed-package-list
      (package-refresh-contents)
      (setq smf/refreshed-package-list t)))

  (advice-add 'package-install
              :before
              (lambda (&rest args)
                (smf/ensure-refreshed)))
#+END_SRC

**** Customise package repositories to install from

By default Emacs only installs files from [[http://www.gnu.org/software/emacs/manual/html_node/efaq/Packages-that-do-not-come-with-Emacs.html#Packages-that-do-not-come-with-Emacs][ELPA]]. Some of these packages are old
or out of date, and they don't track GitHub repositories.

I want to also add:

- [[https://github.com/milkypostman/melpa#melpa][MELPA]] (tracks GitHub repositories, is much more comprehensive)
- [[https://orgmode.org][Org]] (tracks recent releases of org-mode)

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq package-user-dir (concat "~/.emacs.d/.elpa/" emacs-version))

    (setq package-archives
          '(("gnu"          . "http://elpa.gnu.org/packages/")
            ("melpa"        . "http://melpa.org/packages/")
            ("org"          . "http://orgmode.org/elpa/")))

    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)))
  (unless (featurep 'use-package)
    (require 'diminish)
    (require 'bind-key)
    (use-package use-package
      :commands (use-package-autoload-keymap)
      :defer 5))
  (eval-when-compile (require 'use-package))
#+END_SRC

I like seeing the package loading and installing in the message bar, so let's
enable that

#+BEGIN_SRC emacs-lisp
  (setq use-package-verbose t)
#+END_SRC

*** benchmarking

A bit useless while packages are installing but we'll use this for profiling a
regular start-up (i.e. one where we didn't change this config file and nothing
has to install)

#+BEGIN_SRC emacs-lisp
  (use-package benchmark-init
    :ensure t
    :config
    (benchmark-init/activate))
#+END_SRC

*** async mode

Very much needed. smtp and paradox (among others) will take advantage of this
package.

#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t)
#+END_SRC

*** diminish

[[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] removes or abbreviates the minor mode indicators that can clutter up
one's modeline. Since =use-package= utilizes this, we put this right after
installing =use-package=.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :demand t
    :diminish subword-mode
    :diminish eldoc-mode
    :diminish auto-revert-mode
    :diminish hs-minor-mode
    :diminish abbrev-mode
    :diminish overwrite-mode
    :diminish global-whitespace-mode
    :diminish auto-fill-function)
#+END_SRC

** Client/server

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server][client/server]] model for editing. The client is invoked via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Invoking-emacsclient.html][the
=emacsclient= command]]. More information on configuration is available on the
[[http://www.emacswiki.org/emacs/EmacsClient][EmacsWiki EmacsClient page]].

We make sure the server is running, additionally guarded to check if the version
of Emacs we're using supports the server package:

#+BEGIN_SRC emacs-lisp
  (use-package server
    :config
    (setq server-use-tcp t)
    (unless (server-running-p)
      (server-start)))
#+END_SRC

** Editing defaults

Emacs comes with a collection of strange defaults. See [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's
=sane-defaults.el= file]] for some commentary.

*** Line widths and wrapping

The default wrap width (known as [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Filling.html][filling]]) for Emacs is 70 characters. Modern
conventions state that 80 characters is the standard:

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 79)
#+END_SRC

I don't type double-space sentences, so make sure that Emacs doesn't look for
double-spaces after periods to fill paragraphs correctly:

#+BEGIN_SRC emacs-lisp
  (setq-default sentence-end-double-space nil)
#+END_SRC

*** Trailing whitespace

Most UNIX tools work best when there's a trailing newline on all files. Enable
that option:

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

Emacs has lots of other options for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Useless-Whitespace.html][managing superfluous whitespace]].

*** Indentation

I don't use tabstops in files, and my default tab width is 4 characters.

It's worth noting that Emacs can override either of those on a per-file/mode
basis, so Makefiles, Ruby etc. will still get the correct indentation rules.

#+BEGIN_SRC emacs-lisp
  (setq-default
   indent-tabs-mode nil
   tab-width 2
   tab-stop-list (number-sequence 2 120 2)
   sh-basic-offset 2
   sh-indentation 2
   c-basic-offset 2
   web-mode-code-indent-offset 2
   web-mode-markup-indent-offset 2
   web-mode-css-indent-offset 2
   web-mode-sql-indent-offset 2)
#+END_SRC

**** Auto-indentation

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Indent-Convenience.html][Electric indent mode]] was added in Emacs 24.1, and it enables automatic indentation when typing a newline. [[http://emacsredux.com/blog/2013/03/29/automatic-electric-indentation][More about electric indent mode on Emacs Redux]].

First we define convenience toggling functions we can use in a hook (or interactively):

#+BEGIN_SRC emacs-lisp
  (defun smf/turn-on-electric-indent-mode ()
    "Turns on electric-indent-mode"
    (interactive)
    (electric-indent-mode 1))

  (defun smf/turn-off-electric-indent-mode ()
    "Turns off electric-indent-mode"
    (interactive)
    (electric-indent-mode -1))
#+END_SRC

then we enable it for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Program-Modes.html][the generic abstract programming mode =prog-mode=,
introduced in Emacs 24.1]] ([[http://emacsredux.com/blog/2013/04/05/prog-mode-the-parent-of-all-programming-modes/][more about =prog-mode= on Emacs Redux]]):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'smf/turn-on-electric-indent-mode)
#+END_SRC

*** Encoding

I want to have [[http://en.wikipedia.org/wiki/UTF-8][UTF-8]] by default. [[http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/][Emacs unfortunately has a few settings that
govern encoding]], so we should set them all at once:

#+BEGIN_SRC emacs-lisp
  ;; Utf-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
  (setenv "LANG" "en_US.ut8") ; ensure subprocesses get the right env variable
#+END_SRC

*** Smart =beginning-of-line=

=C-a= is mapped to =beginning-of-line= by default, which moves point to position
0 on the current line. [[http://irreal.org/blog/?p=1946][The irreal blog suggests a smarter alternative]] that moves
the point to the first non-whitespace character first, and then position 0, with
extra presses toggling the position:

#+BEGIN_SRC emacs-lisp
  (defadvice move-beginning-of-line (around smarter-bol activate)
    ;; Move to requested line if needed.
    (let ((arg (or (ad-get-arg 0) 1)))
      (when (/= arg 1)
        (forward-line (1- arg))))
    ;; Move to indentation on first call, then to actual BOL on second.
    (let ((pos (point)))
      (back-to-indentation)
      (when (= pos (point))
        ad-do-it)))
#+END_SRC

This functionality uses the Emacs concept of [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][advice]], which is a way of modifying
existing functions in-place without redefining the entire thing.

*** Fix minibuffer behaviour

When changing focus to the minibuffer, stop allowing point to move over the
prompt. Code taken from [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][ergoemacs]].

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'minibuffer-avoid-prompt))
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'point-entered))
#+END_SRC

While we're at it, let's allow recursive minibuffers.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

Also, let's save the minibuffer history between sessions. It's 2014. We have the
technology.

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)
  (setq history-length 1000)
#+END_SRC

*** Deleting files

Move files to the trash when deleting:

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

*** Compressed files

Transparently open compressed files:

#+BEGIN_SRC emacs-lisp
  (auto-compression-mode t)
#+END_SRC

*** Active region

Got these from [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's =sane-defaults.el=]]. Show the active region,

#+BEGIN_SRC emacs-lisp
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)
#+END_SRC

Remove text in active region if inserting text,

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** Pop mark

When popping the mark, continue popping until the cursor actually moves. Also,
if the last command was a copy - skip past all the expand-region cruft.

#+BEGIN_SRC emacs-lisp
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (when (eq last-command 'save-region-or-current-line)
        ad-do-it
        ad-do-it
        ad-do-it)
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+END_SRC

*** Window mark

If this is true, then =erc='s scrolling is broken.

#+BEGIN_SRC emacs-lisp
  (setq switch-to-buffer-preserve-window-point nil)
#+END_SRC

** Keyboard

*** Modifier keys

- =C-= means =Control= in combination with another key, eg =C-x= means =Ctrl + x=
- =M-= means =Meta= in combination with another key. This is usually =Alt=, or
  =⌘= on OS X (by default). =Esc= also serves as =Meta= if it's not separately
  bound. On OS X I want to use left =⌥= for =Meta=, and leave right =⌥= alone:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq-default ns-alternate-modifier 'meta)
    (setq-default mac-option-modifier 'meta)
    (setq-default ns-right-alternate-modifier nil))
#+END_SRC

- =s-= means [[http://en.wikipedia.org/wiki/Super_key_(keyboard_button)][super key]]. On OS X I want this to be =⌘=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq-default ns-command-modifier 'super)
    (setq-default mac-command-modifier 'super))
#+END_SRC

- =H-= means [[http://en.wikipedia.org/wiki/Hyper_key][hyper key]]. On OS X I want this to be =fn=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq-default ns-function-modifier 'hyper)
    (setq-default mac-function-modifier 'hyper))
#+END_SRC

*** Basic remappings

The below are some remappings I got from [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge's Effective Emacs]] article.
They're designed to map some slightly difficult but very common mappings to
things that are easier to type.

**** Prefer =backward-kill-word= over Backspace

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item3][Yegge's Item 3]]. This emulates readline =C-w= command to
=backward-kill-word=. The command that used to live there (=kill-region=) is not
needed since the backspace key works just fine in that case.

#+BEGIN_SRC emacs-lisp
  ;; deletes backward until a space is hit
  (defun smf/backward-kill-word ()
    (interactive)
    (if (and transient-mark-mode mark-active)
        (kill-region (point) (mark))
      (progn
        (delete-region (point) (save-excursion (skip-syntax-backward " ") (point)))
        (delete-region (point) (save-excursion (skip-syntax-backward "^ ") (point))))))

  (global-set-key (kbd "C-w") 'smf/backward-kill-word)
#+END_SRC

**** Quick window switching

Usually one must type =C-x o= to switch between windows - make that quicker by
also mapping =M-o=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-o") 'other-window)
  ;; Moving between windows
  (global-set-key (kbd "C-s-<up>") 'windmove-up)
  (global-set-key (kbd "C-s-<down>") 'windmove-down)
  (global-set-key (kbd "C-s-<right>") 'windmove-right)
  (global-set-key (kbd "C-s-<left>") 'windmove-left)
#+END_SRC

**** Buffer management

Add a key combination to revert the current buffer (re-read the contents from
disk):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC

Most of the time I want the buffer to be reverted automatically:

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

**** Increase / decrease font size

I never remember the keybindings for this:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-=") 'text-scale-increase)
  (global-set-key (kbd "s--") 'text-scale-decrease)
  (global-set-key (kbd "s-0") '(lambda () (interactive) (text-scale-adjust 0)))
#+END_SRC

** Interface

*** Remove chrome

To ensure that all scrollbars, toolbars etc. are turned off, we run this as
early as possible.

#+NAME: turn-off-chrome
#+BEGIN_SRC emacs-lisp
  (dolist (mode '(tool-bar-mode scroll-bar-mode))
    (when (fboundp mode) (funcall mode -1)))
#+END_SRC

*** Startup buffers

Turn off the startup screen, and always show =*scratch*=.

#+NAME: turn-off-startup
#+BEGIN_SRC emacs-lisp
  ;; inhibit startup screen
  (setq inhibit-startup-screen t
        ;; Show *scratch* on start
        initial-buffer-choice t)
#+END_SRC

*** Font

I use [[https://github.com/tonsky/FiraCode][Fira Code]] as my default coding font:

#+BEGIN_SRC emacs-lisp
  ;; set the font
  (when (window-system)
    (set-frame-font "Fira Code"))
  (if (fboundp 'mac-auto-operator-composition-mode)
      (mac-auto-operator-composition-mode))
#+END_SRC

Uncomment the last line to generate the table of ligature codes.

*** ImageMagick

If available, let's use imagemagick.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))
#+END_SRC

*** Syntax highlighting

Syntax highlighting in Emacs is called [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Font-Lock.html][font locking]]. It's enabled by
=font-lock-mode=. This turned on by default in modern Emacs systems, but it's
worth keeping around:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC

Emacs also supports multiple levels of complexity for highlighting. Setting this
value to =t= forces it to pick the maximum available (also the default):

#+BEGIN_SRC emacs-lisp
  (setq font-lock-maximum-decoration t)
#+END_SRC

*** Line and column numbers

Emacs doesn't display line numbers by the code by default. For that you want
[[http://www.emacswiki.org/emacs/LineNumbers#toc1][Linum mode]].

I want to display the current line number in the [[http://www.emacswiki.org/emacs/ModeLine][mode line]], and also the
current column number:

#+BEGIN_SRC emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+END_SRC

*** Tooltips

Emacs convention is to show help and other inline documentation in the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/message.html][message
area]]. Show help there instead of using an OS tooltip:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (tooltip-mode -1))
#+END_SRC

*** Dialogue boxes and windows

Just don't show them. Use native Emacs controls:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq use-dialog-box nil))
#+END_SRC

Make the window title display the full path of the file I'm currently editing:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b")))))
#+END_SRC

Aside: Emacs calls OS windows [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames][frames]] and divisions within frames [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][windows]]. [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Titles.html][More
information on frame titles]].

*** Cursor

I prefer a box, non-blinking cursor. So, turn off that blinking:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq-default cursor-type 'box)
    (blink-cursor-mode (- (*) (*) (*))))
#+END_SRC

Depending on the mode, let's [[http://www.emacswiki.org/emacs/ChangingCursorDynamically][change the cursor]].

#+BEGIN_SRC emacs-lisp
  (defvar smf/read-only-color       "gray")
  (defvar smf/read-only-cursor-type 'hbar)
  (defvar smf/overwrite-color       "red")
  (defvar smf/overwrite-cursor-type 'box)
  (defvar smf/normal-color          "gray")
  (defvar smf/normal-cursor-type    'box)

  (defun smf/set-cursor-according-to-mode ()
    "change cursor color and type according to some minor modes."

    (cond
     (buffer-read-only
      (set-cursor-color smf/read-only-color)
      (setq cursor-type smf/read-only-cursor-type))
     (overwrite-mode
      (set-cursor-color smf/overwrite-color)
      (setq cursor-type smf/overwrite-cursor-type))
     (t
      (set-cursor-color smf/normal-color)
      (setq cursor-type smf/normal-cursor-type))))

  (add-hook 'post-command-hook 'smf/set-cursor-according-to-mode)
#+END_SRC

*** Typing

Show the modifier combinations I just typed almost immediately:

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

Don't make me type =yes= or =no= to boolean interface questions:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Code commenting

A drop-in replacement for comment-dwim. If no region is selected and current
line is not blank and we are not at the end of the line, then comment current
line.

#+BEGIN_SRC emacs-lisp
  (defun smf/comment-dwim-line (&optional arg)
    (interactive "*P")
    (comment-normalize-vars)
    (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
        (comment-or-uncomment-region (line-beginning-position) (line-end-position))
      (comment-dwim arg)))
  (global-set-key (kbd "M-;") #'smf/comment-dwim-line)
#+END_SRC

Comment or uncomment the region or current line if no active region.

#+BEGIN_SRC emacs-lisp
  (defun smf/comment-or-uncomment-region-or-line ()
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))
  (global-set-key (kbd "s-;") #'smf/comment-or-uncomment-region-or-line)
#+END_SRC

*** Bells

Don't make a sound when [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Beeping.html][ringing a bell]] - flash a visual bell instead:

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Override the =ring-bell-function= to conditionally ring the bell only when it's
not a valid quit case like hitting =esc= or =C-g=. Generally this means the bell
will only ring when there's actually an error raised somehow:

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function
        (lambda ()
          "Only rings the bell if it's not a valid quit case, e.g
  keyboard-quit"
          (unless (memq this-command
                        '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
            (ding))))
#+END_SRC

*** Buffer naming

By default Emacs resolves conflicting buffer names by appending a number to
them. For instance, if I open =~/src/thing/init.el= and
=~/src/other-thing/init.el= they'll be named =init.el= and =init.el<2>=
respectively.

We can use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][Uniquify]] library to name them =thing/init.el= and
=other-thing/init.el=, which is much easier to make sense of.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

** OS X specific configuration

Besides the keyboard configuration above, there are some other specific things I
do on OS X. On OS X =system-type= is the symbol =darwin=.

*** Spelling correction

On the mac, the default mouse bindings are problematic since a two-finger click
is =mouse-3= and not =mouse-2=:

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :diminish flyspell-mode
    :commands (flyspell-mode flyspell-prog-mode flyspell-correct-word)
    :init
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode)
    :config
    ;; ispell isn't generally available on macos so let's use aspell
    (when (executable-find "aspell")
      (setq ispell-program-name (executable-find "aspell")))

    ;; Sets flyspell correction to use two-finger mouse click
    (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word))
#+END_SRC

*** dired fixes

OS X's bundled version of =ls= isn't the GNU one, so it doesn't support the
=--dired= flag. Emacs caters for that use case:

#+BEGIN_SRC emacs-lisp
  (setq dired-use-ls-dired nil)
#+END_SRC

*** sRGB display fixes

As of Emacs 24.4, [[http://lists.gnu.org/archive/html/emacs-devel/2013-12/msg00741.html][Emacs natively supports proper sRGB]] values on OS X:

#+BEGIN_SRC emacs-lisp
  (setq-default ns-use-srgb-colorspace t)
#+END_SRC

*** Terminal integration

Using this configuration, Emacs runs best in [[http://iterm2.com][iTerm2]].

On the desktop, Emacs integrates with the OS X clipboard, so =kill= etc. copy to
the clipboard, and =yank= copies from the clipboard.

Obviously this doesn't work in the terminal, so we need to use the
=interprogram-(cut|paste)-function= variables to copy/paste. Most of this code
gotten from [[http://mindlev.wordpress.com/2011/06/13/emacs-in-a-terminal-on-osx/#comment-20][this blog comment]].

#+BEGIN_SRC emacs-lisp
  (when (and (not (display-graphic-p)) (eq system-type 'darwin))
    (defun smf/copy-from-osx ()
      "Copies the current clipboard content using the `pbcopy` command"
      (shell-command-to-string "pbpaste"))

    (defun smf/paste-to-osx (text &optional push)
      "Copies the top of the kill ring stack to the OSX clipboard"
      (let ((process-connection-type nil))
        (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
          (process-send-string proc text)
          (process-send-eof proc))))

    (setq interprogram-cut-function 'smf/paste-to-osx)
    (setq interprogram-paste-function 'smf/copy-from-osx))
#+END_SRC

Also, allow pasting selection outside of Emacs:

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t)
#+END_SRC

*** Fullscreen support

On Emacs 24.4 and above, Lion-style fullscreen display is supported but I
dislike it. Define a method to toggle fullscreen pre-Lion.

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (fboundp 'toggle-frame-fullscreen))
    (defun smf/toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      (set-frame-parameter nil 'fullscreen
                           (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

      (global-set-key (kbd "C-s-f") #'smf/toggle-fullscreen))
#+END_SRC

On the Yosemite beta, =ns-use-native-fullscreen= is =nil=.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq-default ns-use-native-fullscreen nil))
#+END_SRC

Start emacs in fullscreen,

#+BEGIN_SRC emacs-lisp
  (smf/toggle-fullscreen)
#+END_SRC

*** OS X keybindings

There are a lot of native OS X-isms that I would like to keep. Things such =⌘-a=
to select the whole buffer, or =⌘-c= to copy.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-a") 'mark-whole-buffer)
    (global-set-key (kbd "s-v") 'yank)
    (global-set-key (kbd "s-c") 'kill-ring-save)
    (global-set-key (kbd "s-x") 'kill-region)
    (global-set-key (kbd "s-s") 'save-buffer)
    (global-set-key (kbd "s-l") 'goto-line)
    (global-set-key (kbd "s-w") 'delete-window)
    (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
    (global-set-key (kbd "s-k") 'kill-this-buffer)
    (global-set-key (kbd "s-r") 'recompile)
    (global-set-key (kbd "s-}") 'forward-paragraph)
    (global-set-key (kbd "s-{") 'backward-paragraph)
    (global-set-key (kbd "s-g") 'isearch-repeat-forward)
    (global-set-key [(H left)]  'beginning-of-buffer)
    (global-set-key [(H right)] 'end-of-buffer)
    (global-set-key [(H down)]  [?\C-v])
    (global-set-key [(H up)]    [?\M-v]))
#+END_SRC

The =⌘-backspace= deletes text from the current position to the beginning of the
line.

#+BEGIN_SRC emacs-lisp
  (global-set-key [s-backspace] [?\C- ?\C-a backspace])
#+END_SRC

** Loading Themes

Yay, themes!

*** spaceline

Pretty impressed by spacelines + all-the-icons integration.

#+BEGIN_SRC emacs-lisp
  (setq custom-safe-themes t)             ; don't ask about installing themes

  (use-package all-the-icons
    :ensure t
    :if window-system)

  (use-package powerline
    :after all-the-icons
    :ensure t
    :if window-system
    :config (setq-default powerline-default-separator 'nil))

  (use-package spaceline
    :after powerline
    :demand
    :ensure t
    :config (setq-default mode-line-format
                          '("%e" (:eval (spaceline-ml-ati)))))

  (use-package spaceline-custom
    :after spaceline-colors
    :demand
    :load-path "init"
    :init (add-hook 'after-init-hook 'spaceline-update-faces)
    :config (advice-add 'load-theme :after 'spaceline-update-faces))

  (use-package spaceline-colors
    :after spaceline
    :load-path "init"
    :demand)
#+END_SRC

*** themes

Some basic themes that work with =spaceline= and =all-the-icons=.

#+BEGIN_SRC emacs-lisp
  (use-package moe-theme :ensure t)

  ;; deferred for now
  (use-package creamsody-theme :ensure t :defer t)
  (use-package gruvbox-theme :ensure t :defer t)
  (use-package suscolors-theme :ensure t :defer t)
  (use-package atom-one-dark-theme :ensure t :defer t)
  (use-package forest-blue-theme :ensure t :defer t)
  (use-package liso-theme :ensure t :defer t)
  (use-package peacock-theme :ensure t :defer t)
  (use-package solarized-theme :ensure t :defer t)

  (defun smf/remove-mode-line-box (&rest args)
    (set-face-attribute 'mode-line nil :box nil :underline nil)
    (set-face-attribute 'mode-line-inactive nil :box nil :underline nil))

  (when window-system
    (smf/remove-mode-line-box)
    (load-theme 'moe-dark))
#+END_SRC

** Utility functions

*** Get keychain password

Use =auth-source= for all the things!

#+BEGIN_SRC emacs-lisp
  (use-package auth-source
    :defer t
    :config
    ;; define a helper method to search auth-source and get a password; mostly
    ;; needed due to lack of integration of znc and hipchat with auth-source
    (defun smf/auth-source-pass (user server)
      (let* ((found (nth 0 (auth-source-search :user user
                                               :host server
                                               :max 1))))
        (if found
            (let ((secret (plist-get found :secret)))
              (if (functionp secret)
                  (funcall secret)
                secret)))))

    (setq auth-sources '(macos-keychain-internet)))
#+END_SRC

*** Conditionally kill Emacs

When I'm in an emacsclient, I probably just want the client to die rather than
the entire server. And, when I kill my server, I want Emacs to confirm this with
me:

#+BEGIN_SRC emacs-lisp
  (defun smf/kill-emacs ()
    "If this buffer is a client, just kill it, otherwise confirm
  the quit."
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (if (= (length (frame-list)) 1)
        (save-buffers-kill-terminal))))
#+END_SRC

Enable this, and override the default command Emacs assigns to kill itself:

#+BEGIN_SRC emacs-lisp
  (define-key (current-global-map) [remap save-buffers-kill-terminal] 'smf/kill-emacs)
#+END_SRC

Also, when using an emacsclient that is waiting, I don't want a prompt that asks
if I really want to exit. So, we define our own function and bind it to =⌘-k=.

#+BEGIN_SRC emacs-lisp
  (defun smf/kill-buffer ()
    "Murderface a buffer, don't listen to nobody, son!"
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (kill-this-buffer)))

  (add-hook 'server-switch-hook
            (lambda ()
              (local-set-key (kbd "s-k") 'smf/kill-buffer)))
#+END_SRC

*** narrow-or-widen-dwim

Taken from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][here]], this function defines a handy way to narrow the buffer. We'll
add a launcher for it bound to 'n'.

#+BEGIN_SRC emacs-lisp
  (defun smf/narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  (global-set-key (kbd "H-n") 'smf/narrow-or-widen-dwim)
#+END_SRC

*** Delete to end of buffer

In emails (and sometimes other places, too) I frequently want to delete the rest
of the buffer. We'll bind this to =C-M-d=

#+BEGIN_SRC emacs-lisp
  (defun smf/delete-to-end-of-buffer (add-to-kill-ring-p)
    "Deletes from point to end of buffer. If prefix argument is
     given, kill the region, adding it to the kill ring."
    (interactive "P")
    (if add-to-kill-ring-p
        (kill-region (point) (point-max))
      (delete-region (point) (point-max))))

  (global-set-key (kbd "C-M-d") 'smf/delete-to-end-of-buffer)
#+END_SRC

** ediff

[[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][ediff]] is a full-featured visual diff and merge tool, built into Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :commands smf/hg-mergetool-emacsclient-ediff
    :config
    ;; finally, we add customizations for using ediff with mercurial
    (defvar smf/hg-mergetool-emacsclient-ediff-active nil)
    (defvar smf/local-ediff-saved-frame-configuration)
    (defvar smf/local-ediff-saved-window-configuration)

    ;; Make sure that the window split is always side-by-side:
    (setq ediff-split-window-function 'split-window-horizontally

          ;; ignore whitespace changes
          ediff-diff-options "-w"

          ;; only ever use one set of windows in one frame
          ediff-window-setup-function 'ediff-setup-windows-plain

          ;; don't keep ediff file instances around
          ediff-keep-variants nil)

    (defvar ediff-after-quit-hooks nil
      "* Hooks to run after ediff or emerge is quit.")

    (defadvice ediff-quit (after edit-after-quit-hooks activate)
      (run-hooks 'ediff-after-quit-hooks))

    (defun smf/local-ediff-before-setup-hook ()
      (setq smf/local-ediff-saved-frame-configuration (current-frame-configuration))
      (setq smf/local-ediff-saved-window-configuration (current-window-configuration))
      (global-auto-revert-mode 0)
      ;; (local-ediff-frame-maximize)
      (if smf/hg-mergetool-emacsclient-ediff-active
          (raise-frame)))

    (defun smf/local-ediff-quit-hook ()
      (set-frame-configuration smf/local-ediff-saved-frame-configuration)
      (set-window-configuration smf/local-ediff-saved-window-configuration))

    (defun smf/local-ediff-suspend-hook ()
      (set-frame-configuration smf/local-ediff-saved-frame-configuration)
      (set-window-configuration smf/local-ediff-saved-window-configuration))

    ;; Useful for ediff merge from emacsclient.
    (defun smf/hg-mergetool-emacsclient-ediff (local remote base merged)
      (setq smf/hg-mergetool-emacsclient-ediff-active t)
      (if (file-readable-p base)
          (ediff-merge-files-with-ancestor local remote base nil merged)
        (ediff-merge-files local remote nil merged))
      (recursive-edit))

    (defun smf/hg-mergetool-emacsclient-ediff-after-quit-hook ()
      (global-auto-revert-mode t)
      (exit-recursive-edit))

    (add-hook 'ediff-after-quit-hooks
    'smf/hg-mergetool-emacsclient-ediff-after-quit-hook 'append))
    (add-hook 'ediff-before-setup-hook 'smf/local-ediff-before-setup-hook)
    (add-hook 'ediff-quit-hook 'smf/local-ediff-quit-hook 'append)
    (add-hook 'ediff-suspend-hook 'smf/local-ediff-suspend-hook 'append)
#+END_SRC

** ERC

*** Setup

[[http://en.wikipedia.org/wiki/Internet_Relay_Chat][IRC]] will [[https://xkcd.com/1782/][always be popular]], so we'll use Emacs IRC.

#+BEGIN_SRC emacs-lisp
  (use-package tls :defer t)
  (use-package erc-join :after erc)
  (use-package erc-menu :after erc)
  (use-package shr
    :commands shr-render-region
    :config
    ;; this changed in emacs 25 ... I still prefer monospaced fonts
    (setq shr-use-fonts nil))

  (use-package erc
    :after (company tls)
    :commands (erc erc-tls)
    :bind (:map erc-mode-map
                ("<escape>" . smf/bury-buffer)
                ("C-'" . smf/mark-read))
    :config
    (setq-default
     erc-prompt ">"
     erc-email-userid "sean.michael.farley@gmail.com"
     erc-autojoin-channels-alist '((".*smf.io.*" "&bitlbee" "#bitbucket"))
     erc-prompt-for-password nil
     erc-prompt-for-nickserv-password nil
     erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                               "324" "329" "332" "333" "353" "477")
     erc-hide-list '("JOIN" "PART" "QUIT")
     erc-quit-reason 'erc-quit-reason-normal
     erc-track-exclude-server-buffer t

     ;; when having a flaky connection erc attempts to reconnect ad infinitum,
     ;; so let's turn that off

     erc-server-auto-reconnect nil

     ;; when people send me a message (called 'query' in IRC speak), I want the
     ;; buffer to pop up and notify me,
     erc-auto-query 'buffer
     erc-query-display 'buffer)

    ;; let's enable some convenient modules
    (add-to-list 'erc-modules 'dcc)

    ;; enable shit
    (erc-spelling-mode 1)

    ;; As a default, only private messages trigger automatic creation of query
    ;; buffers. I want the same behavior when I receive all notices
    (add-hook 'erc-after-connect
              (lambda (server nick)
                (add-hook 'erc-server-NOTICE-hook 'erc-auto-query)))

    (add-hook 'erc-mode-hook 'company-mode)

    (defun smf/mark-read ()
      "Mark buffer as read up to current line by coloring the text gray."
      (interactive)
      (let ((inhibit-read-only t))
        (put-text-property
         (point-min) (line-beginning-position)
         'face       'font-lock-comment-face)))

    (defun smf/bury-buffer ()
      "Bury buffer and maybe close its window."
      (interactive)
      (smf/mark-read)
      (bury-buffer)))
#+END_SRC

*** erc patches from jwiegly

#+BEGIN_SRC emacs-lisp
  (use-package erc-alert
    :after erc
    :load-path "lisp")
#+END_SRC

*** ZNC

I use [[http://wiki.znc.in/ZNC][ZNC]] to always stay connected to IRC channels, so when I close a buffer I
don't want to quit the channel, just detach from my server. Also, we use the
keychain method defined above to get our password.

The =auth-source= could below is borrowed from [[http://doc.rix.si/cce/cce-irc.html][rrix]].

#+BEGIN_SRC emacs-lisp
  (use-package znc
    :after erc
    :ensure t
    :commands znc-all
    :config
    (defun smf/znc-add-server (server port user networks)
      "Add a server to the list of ZNC servers.

  We use SSL unconditionally. Moreover, we don't store the password
  but put nil instead. Also, we tweak the username to contain the
  network name later, this will be separated again."
      (add-to-list 'znc-servers
                   (list server port t
                         (mapcar
                          (function
                           (lambda (slug)
                             (list slug (format "%s/%s" user slug) nil)))
                          networks))))

    (defun smf/znc-erc-ssl-connector (&rest R)
      "Connect to ERC using SSL and retrieve password with `auth-source-search'.

  Moreover, handle multiple networks by sending the password with
  the appropriate network slug that we extract from the nick."
      (let* ((user (nth 0 (split-string (plist-get R :nick) "/")))
             (slug (nth 1 (split-string (plist-get R :nick) "/")))
             (pass (smf/auth-source-pass user (plist-get R :server))))
        (when pass
          (plist-put R :password (format "%s/%s:%s" user slug pass))
          (plist-put R :nick user)
          (apply 'erc-tls R))))

    (setq
     ;; use our new connector instead of the default one
     znc-erc-ssl-connector #'smf/znc-erc-ssl-connector

     znc-detatch-on-kill t
     znc-servers nil)

    (smf/znc-add-server "smf.io" 6697 "smf" '(freenode bitlbee)))
#+END_SRC

*** erc-tweet

Put the actual tweet into the buffer.

#+BEGIN_SRC emacs-lisp
  (use-package erc-tweet
    :after erc
    :ensure t
    :defer t
    :config
    (add-to-list 'erc-modules 'tweet))
#+END_SRC

*** highlight nicknames

#+BEGIN_SRC emacs-lisp
  (use-package erc-hl-nicks
    :after erc
    :ensure t
    :defer t
    :config
    ;; this makes colors look nice with darker themes
    (setq erc-hl-nicks-color-contrast-strategy '(invert contrast)))
#+END_SRC

*** cloud-to-butt

This will never get old.

#+BEGIN_SRC emacs-lisp
  (use-package cloud-to-butt-erc
    :after erc
    :ensure t
    :defer t)
#+END_SRC

*** hipchat

A package I wrote to help connect to hipchat and display things like (awyeah).

#+BEGIN_SRC emacs-lisp
  (use-package erc-hipchatify
    :after erc
    :ensure t
    :defer t
    :config
    (setq erc-hipchatify-token `,(smf/auth-source-pass "smf/token" "hipchat.com")
          erc-hipchatify-email "sfarley@atlassian.com"

          ;; set the channel names (buffer names) for which to replace 'nick'
          ;; with '@nick'
          erc-hipchatify-mention-channels '("smf"
                                            "#bitbucket-social"
                                            "#bitbucket-cloud"
                                            "#bitbucket-support"
                                            "#bitbucket-bugfix"
                                            "#bitbucket-sf"
                                            "#bitbucket-ops"
                                            "#sourcetree"))

    (add-to-list 'erc-modules 'hipchatify)
    (erc-update-modules))
#+END_SRC

*** Switch to buffer or connect to znc

If I haven't connected to my ZNC server, then we connect to it; otherwise, just
switch to the buffer.

#+BEGIN_SRC emacs-lisp
  (defun smf/erc-start-or-switch (channel)
    "Connect to ERC, or switch to given channel"
    (interactive)
    ;; switch to the scratch buffer so cwd isn't in a project
    (with-current-buffer (get-buffer "*scratch*")
      (if (get-buffer "*irc-freenode*") ;; ERC already active?
          (progn
            (set-buffer "*irc-freenode*")
            (if (erc-server-process-alive)
                (switch-to-buffer channel) ;; yes: switch to #channel
              (znc-all)))                  ;; no: start ERC
        (znc-all))))                       ;; no: start ERC

  (defun smf/bitbucket ()
    (interactive)
    (smf/erc-start-or-switch "#bitbucket"))

  (defun smf/mercurial ()
    (interactive)
    (smf/erc-start-or-switch "#mercurial"))

  (defun smf/disable-chat ()
    (interactive)
    (znc-all t)
    (define-key smf/launcher-map "b" nil)
    (define-key smf/launcher-map "m" nil)
    (message "Disabled ERC/ZNC"))

  (defun smf/enable-chat ()
    (interactive)
    (define-key smf/launcher-map "b" 'smf/bitbucket)
    (define-key smf/launcher-map "m" 'smf/mercurial)
    (message "Enabled ERC/ZNC"))
  (smf/enable-chat)
#+END_SRC

*** Query any user

Below adds the ability to launch a new chat with any nick. It amalgamates all
nicks in all channels because that is simple and hasn't been a problem for me
yet. My [[http://www.bitlbee.org][BitlBee]] server appends "|fb" or "|gtalk" for the corresponding chat
method so that takes care of most potential name conflicts.

#+BEGIN_SRC emacs-lisp
  (defun smf/user-keys (erc-channel-users)
  "Convert the ERC-CHANNEL-USERS hash into an equivalent list-based form."
  (let ((alist '()))
    (maphash (lambda (key value)
               (push (erc-server-user-nickname (car value)) alist))
             erc-channel-users)
    alist))

  (defun smf/buffer-users (buffer)
    "Return users for a given ERC buffer"
    (set-buffer buffer)
    (smf/user-keys erc-channel-users))

  (defun smf/erc-chat (nick)
    "Start a query with nick"
    (interactive
     (list (completing-read "Nick: "
                            (append (smf/buffer-users "&bitlbee")
                                    (smf/buffer-users "#mercurial")
                                    (smf/buffer-users "#bitbucket")))))
    (cond ((member nick (smf/buffer-users "&bitlbee"))
           (set-buffer "&bitlbee"))
          ((member nick (smf/buffer-users "#mercurial"))
           (set-buffer "#mercurial"))
          ((member nick (smf/buffer-users "#bitbucket"))
           (set-buffer "#bitbucket")))

    (erc-cmd-QUERY nick))

  (smf/add-launcher "c" 'smf/erc-chat)
#+END_SRC

** LaTeX

I love [[http://en.wikipedia.org/wiki/LaTeX][LaTex]]. It's the best way to typeset a document.

*** AucTeX

Let's start by installing some LaTeX specific plugins (mostly AucTex-related)
and initialize them. [[http://mactex-wiki.tug.org/wiki/index.php/SyncTeX][SyncTeX]] enables synchronization between source TeX files
and the resulting pdf file.

#+BEGIN_SRC emacs-lisp
  ;; define map to silence byte compiler
  (defvar LaTeX-mode-map)

  (use-package tex
    :ensure auctex
    :mode ("\\.tex\\'" . latex-mode)
    :commands (latex-mode LaTeX-mode plain-tex-mode smf/latexmk-compile)
    :diminish iimage-mode
    :diminish outline-minor-mode
    :diminish reftex-mode
    :diminish abbrev-mode
    :bind (:map LaTeX-mode-map
                ("C-c C-a" . smf/latexmk-compile))
    :config
    (setq-default TeX-auto-save t
                  TeX-parse-self t
                  LaTeX-item-indent 0
                  TeX-clean-confirm nil ; don't ask me to clean
                  TeX-PDF-mode t        ; who uses dvi?
                  outline-minor-mode-prefix (kbd "C-c o")
                  TeX-source-correlate-method 'synctex
                  TeX-source-correlate-start-server t
                  TeX-view-program-selection '((output-pdf "PDF Tools"))
                  TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view)))

    ;; taken from http://www.emacswiki.org/AUCTeX for automatic detection of the
    ;; master file

    (defun smf/guess-TeX-master (filename)
      "Guess the master file for FILENAME from currently open .tex files."
      (let ((candidate nil)
            (filename (file-name-nondirectory filename)))
        (save-excursion
          (dolist (buffer (buffer-list))
            (with-current-buffer buffer
              (let ((name (buffer-name))
                    (file buffer-file-name))
                (if (and file (string-match "\\.tex$" file))
                    (progn
                      (goto-char (point-min))
                      (if (re-search-forward (concat "\\\\input{" filename "}") nil t)
                          (setq candidate file))
                      (if (re-search-forward (concat "\\\\include{" (file-name-sans-extension filename) "}") nil t)
                          (setq candidate file))))))))
        (if candidate
            (message "TeX master document: %s" (file-name-nondirectory candidate)))
        candidate))

    ;; latexmk is a handy way to compile the TeX source the correct number of
    ;; times, so we'll create a convenient binding for that
    (defun smf/latexmk-compile ()
      (interactive)
      (save-buffer)
      (TeX-command "LatexMk" 'TeX-master-file -1))

    (defun smf/latex-mode-hook ()
      (turn-on-auto-fill)
      (abbrev-mode)
      (LaTeX-math-mode)
      (outline-minor-mode)
      (magic-latex-buffer)
      (setq TeX-master (smf/guess-TeX-master (buffer-file-name))))

    ;; add synctex hook
    (add-hook 'LaTeX-mode-hook #'TeX-source-correlate-mode)
    (add-hook 'LaTeX-mode-hook #'smf/latex-mode-hook)
    (add-hook 'LaTeX-mode-hook #'reftex-mode)
    (add-hook 'LaTeX-mode-hook #'turn-on-reftex))

  (use-package auctex-latexmk
    :after auctex
    :ensure t
    :config
    (auctex-latexmk-setup))
#+END_SRC

*** =magic-latex-buffer=

Magical syntax highlighting for LaTeX-mode buffers.

#+BEGIN_SRC emacs-lisp
  (use-package magic-latex-buffer
    :ensure t
    :defer t
    :diminish magic-latex-buffer)
#+END_SRC

*** RefTeX

You know what eles is awesome? [[http://www.gnu.org/software/auctex/reftex.html][RefTeX]].

#+BEGIN_SRC emacs-lisp
  (use-package reftex
    :commands turn-on-reftex
    :init
    (setq reftex-plug-into-AUCTeX t)
    :config
    (setq-default reftex-enable-partial-scans t
                  reftex-save-parse-info t
                  reftex-use-multiple-selection-buffers t
                  reftex-plug-into-AUCTeX t

                  reftex-cite-prompt-optional-args nil
                  reftex-cite-cleanup-optional-args t

                  reftex-section-levels '(("part" . 0)
                                          ("chapter" . 1)
                                          ("section" . 2)
                                          ("subsection" . 3)
                                          ("frametitle" . 4)
                                          ("subsubsection" . 4)
                                          ("paragraph" . 5)
                                          ("subparagraph" . 6)
                                          ("addchap" . -1)
                                          ("addsec" . -2))

                  reftex-plug-into-AUCTeX t
                  reftex-extra-bindings t
                  reftex-bibfile-ignore-list nil
                  reftex-guess-label-type t
                  reftex-revisit-to-follow t
                  reftex-use-fonts t              ; make colorful toc
                  reftex-toc-follow-mode nil      ; don't follow other toc(s)
                  reftex-toc-split-windows-horizontally t
                  reftex-auto-recenter-toc t
                  reftex-enable-partial-scans t
                  reftex-save-parse-info t
                  reftex-use-multiple-selection-buffers t

                  TeX-fold-env-spec-list '(("[comment]" ("comment"))
                                           ("[figure]" ("figure"))
                                           ("[table]" ("table"))
                                           ("[itemize]" ("itemize"))
                                           ("[enumerate]" ("enumerate"))
                                           ("[description]" ("description"))
                                           ("[overpic]" ("overpic"))
                                           ("[tabularx]" ("tabularx"))
                                           ("[code]" ("code"))
                                           ("[shell]" ("shell")))))
#+END_SRC

*** company-math

#+BEGIN_SRC emacs-lisp
  (use-package company-auctex
    :ensure t
    :after auctex
    :config
    (company-auctex-init))
  (use-package company-math
    :ensure t
    :after auctex
    :config
    (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

*** pdf-tools

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :mode (("\\.pdf\\'" . pdf-view-mode))
    :config
    (pdf-tools-install)
    (setq-default pdf-view-display-size 'fit-page)
    (add-hook 'TeX-after-compilation-finished-functions
              #'TeX-revert-document-buffer))
#+END_SRC

** notmuch

[[https://notmuchmail.org][notmuch]] is a mail indexer and searching. It comes with an emacs client.

*** Setup

#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :ensure t
    :after (async prodigy)
    :commands smf/notmuch-start-or-switch
    :bind (:map notmuch-hello-mode-map
                ("q" . bury-buffer))
    :init
    (smf/add-launcher "e" 'smf/notmuch-start-or-switch)
    :config
    (setq user-mail-address "sean@farley.io"
          user-full-name  "Sean Farley"

          notmuch-archive-tags '("-inbox" "-unread" "+archive")

          ;; don't keep message buffers around
          message-kill-buffer-on-exit t

          ;; address completion via an extra package
          notmuch-address-command "notmuch-addrlookup"

          ;; always prompt for sender (handled later by gnus-alias)
          notmuch-always-prompt-for-sender 't

          ;; prevent replies from showing up in the inbox
          notmuch-fcc-dirs "sent -unread"

          ;; set notmuch as default emacs email program
          mail-user-agent 'notmuch-user-agent

          ;; manually refresh; not a big deal since we use imap idle
          notmuch-hello-auto-refresh 'nil)

    ;; when composing an email, turn on spellchecking and autofill
    (add-hook 'notmuch-message-mode-hook #'auto-fill-mode)
    (add-hook 'notmuch-message-mode-hook #'flyspell-mode)

    ;; function for launching notmuch along with prodigy service
    (defun smf/notmuch-start-or-switch ()
      "Start the imapnotify process or switch to the notmuch buffer"
      (interactive)
      ;; switch to the scratch buffer so cwd isn't in a project
      (with-current-buffer (get-buffer "*scratch*")
        (prodigy-start-service (prodigy-find-service "OfflineIMAP"))
        (notmuch)))

    ;; function for importing a patch from mercurial
    (defun smf/notmuch-show-import-patch ()
      "Import the hg patch.

         If the `default-directory' matches the most recent history
         entry don't bother asking for the git tree again (useful
         for bulk actions)."
      (interactive)
      (let* ((cwd (car ido-work-directory-list)))

        (unless (and (stringp cwd) (string= default-directory cwd))
          (setq cwd (ido-read-directory-name "Target directory: "
                                             cwd
                                             "~/" t))
          (setf ido-work-directory-list
                (cons cwd (delete cwd ido-work-directory-list))))

        (notmuch-show-pipe-message nil (format "hg --cwd %s import -" cwd))))

    ;; mark the email as pre-reviewed
    (defun smf/notmuch-show-set-pre-reviewed ()
      "Sets the patch in patchwork as pre-reviewed."
      (interactive)
      (let* ((msg-id (notmuch-show-get-message-id))
             (pw-cmd (expand-file-name "~/.pwclient"))
             (pw-id-list (process-lines pw-cmd "list"
                                        "-m" (concat "<" (s-chop-prefix "id:" msg-id) ">")
                                        "-n" "1"
                                        "-f" "%{id}"))
             (pw-id (nth 0 pw-id-list)))
        (message "Updating patchwork for patch %s" pw-id)
        (async-start-process "pwclient"
                             pw-cmd
                             (lambda (p)
                               (message "Marked patch as pre-reviewed"))
                             "update"
                             "-s" "Pre-Reviewed"
                             pw-id)))

    ;; 'd' delete stuff in both search and show mode
    (define-key notmuch-show-mode-map "d"
      (lambda ()
        "Move message to trash."
        (interactive)
        (notmuch-show-tag-all (list "+trash" "-inbox" "-unread" "-archive"))
        (notmuch-show-next-thread t)))
    (define-key notmuch-search-mode-map "d"
      (lambda ()
        "Move message to trash."
        (interactive)
        (notmuch-search-tag (list "+trash" "-inbox" "-unread" "-archive"))
        (forward-line)))

    ;; 'S' delete stuff in both search and show mode
    (define-key notmuch-show-mode-map "S"
      (lambda ()
        "Mark message as spam."
        (interactive)
        (notmuch-show-tag-all (list "+spam" "-inbox" "-unread" "-archive"))
        (notmuch-show-next-thread t)))
    (define-key notmuch-search-mode-map "S"
      (lambda ()
        "Mark message as spam."
        (interactive)
        (notmuch-search-tag (list "+spam" "-inbox" "-unread" "-archive"))
        (forward-line)))

    (define-key 'notmuch-show-mode-map "I" 'smf/notmuch-show-import-patch)
    (define-key 'notmuch-show-mode-map "J" 'smf/notmuch-show-set-pre-reviewed))
#+END_SRC

*** sendmail async

#+BEGIN_SRC emacs-lisp
  (use-package smtpmail-async
    :after (notmuch async)
    :config
    (setq send-mail-function           'async-smtpmail-send-it
          message-send-mail-function   'async-smtpmail-send-it
          smtpmail-default-smtp-server "mail.farley.io"
          smtpmail-smtp-server         "mail.farley.io"
          smtpmail-stream-type         'starttls
          smtpmail-smtp-service        587))

#+END_SRC

*** Reply with custom from address

By default, I want my reply email to be the correct one. For example, if I am
replying to an email sent to the MacPorts list then I want =sean@macports.org=
to be used. To achieve this, I wrote a function to handle it:

#+BEGIN_SRC emacs-lisp
  (use-package gnus-alias
    :after notmuch
    :ensure t
    :config
    (setq gnus-alias-identity-alist
          '(("home"
             nil ;; Does not refer to any other identity
             "Sean Farley <sean@farley.io>" ;; Sender address
             nil ;; No organization header
             nil ;; No extra headers
             nil ;; No extra body text
             nil) ;; No signature)
            ("macports"
             nil
             "Sean Farley <sean@macports.org>"
             nil
             nil
             nil
             nil)
            ("atlassian"
             nil
             "Sean Farley <sfarley@atlassian.com>"
             nil
             nil
             nil
             nil)
            ("lsmsa"
             nil
             "Sean Farley <sean@lsmsa.net>"
             nil
             nil
             nil
             nil))

          gnus-alias-default-identity "home"

          gnus-alias-identity-rules
          '(
            ("macports"  ("any" "macports" both) "macports")
            ("lsmsa"  ("any" "lsmsa" both) "lsmsa")
            ("atlassian"  ("any" "atlassian" both) "atlassian")
            )
          )

    (add-hook 'message-setup-hook 'gnus-alias-determine-identity))
#+END_SRC

*** Miscellaneous setting

Set =offlineimap= to be called for fetching new mail. This allows mail to be
updated from within [[notmuch]] with keyboard shortcuts.

#+BEGIN_SRC emacs-lisp
  (use-package offlineimap
    :after notmuch
    :ensure t
    :commands offlineimap
    :config
    (setq offlineimap-mode-line-text nil
          offlineimap-mode-line-symbols '((run . "⟲")
                                          (stop .  "↻")
                                          (exit .  "■")
                                          (signal . "⚑")
                                          (open .  "⊙")
                                          (listen . "⌥")
                                          (closed . "●")
                                          (connect . "…")
                                          (failed . "⌁")))

    ;; Add a hook to get news after offlineimap is finished
    (add-hook 'offlineimap-event-hooks (lambda (msg-type &optional action)
                                         (when (and (equal "finished\n" msg-type)
                                                    (get-buffer "*notmuch-hello*"))
                                           (notmuch-hello 't))))

    (define-key notmuch-hello-mode-map "G" 'offlineimap)
    (define-key notmuch-search-mode-map "G" 'offlineimap))
#+END_SRC

** org

**** init

[[http://orgmode.org][org-mode]] is a plain text system for organising information and notes. We'll set
some basic settings and personal tweaks,

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :mode ("\\.org"  . org-mode)
    :bind (;; I'll change the prefix for these function (instead of using
           ;; smf/launcher) since they are so common
           ("C-c l" . org-store-link)
           ("C-c a" . org-agenda)
           ("C-c c" . org-capture)

           :map org-mode-map
           ;; I use meta-arrow keys for navigation so let's stop org from
           ;; using them to indent
           ("<M-S-left>" . nil)
           ("<M-left>" . nil)
           ("<M-right>" . nil)
           ;; since I commonly mistype =C-c C-'= instead of =C-c '=, let's
           ;; add that keybinding,
           ("C-c C-'" . org-edit-special)

           :map org-src-mode-map
           ("C-c C-'" . org-edit-src-exit)
           ;; I find it infuriating that my muscle memory =⌘+s= in
           ;; =org-src-mode= will save the buffer as a new file. Instead,
           ;; let's make it do the same thing as =C-c '=
           ("s-s" . org-edit-src-exit))
    :config
    ;; set the file for capturing todos
    (defvar smf/org-input "~/Dropbox/org/organizer.org")

    ;; don't auto-fold my documents:
    (setq-default org-startup-folded nil

          ;; automatically apply syntax highlighting:
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          org-ellipsis "⤵"

          ;; and don't prompt
          org-confirm-babel-evaluate nil

          ;; when using imenu, make sure I can follow the outline to the full available
          ;; depth
          org-imenu-depth 6

          ;; also, I like using shift+arrow keys to highlight, so let's set that
          org-support-shift-select 'always

          ;; set up MobileOrg (which is sweet!)
          org-directory "~/Dropbox/org"

          org-default-notes-file smf/org-input

          ;; set to the name of the file where new notes will be stored
          org-mobile-inbox-for-pull smf/org-input

          org-mobile-directory "~/Dropbox/Apps/MobileOrg"

          ;; now, set the agenda files,
          org-agenda-files (list "~/Dropbox/org/organizer.org"
                                 "~/Dropbox/org/bitbucket.org"
                                 "~/Dropbox/org/phd.org"
                                 "~/Dropbox/org/hg.org"
                                 "~/Dropbox/org/personal.org")

          ;; please don't close and mess up my windows,
          org-agenda-window-setup 'current-window
          org-agenda-restore-windows-after-quit 't

          ;; add a nice, little template to use along with some shortcuts
          org-capture-templates
          `(("t" "Tasks" entry
             (file+headline "~/Dropbox/org/organizer.org" "Inbox")
             "* TODO %?\nCaptured %<%Y-%m-%d %H:%M>\n%a\n\n%i" "Basic task2 data")
            ("i" "Interrupting task" entry
             (file+headline "~/Dropbox/org/organizer.org" "Inbox")
             "* STARTED %^{Task}"
             :clock-in :clock-resume))

          org-todo-keywords '((sequence "TODO(t)" "|" "DONE(d)")))

    ;; shortcut to launch file for refiling
    (smf/add-launcher "o" (lambda ()
                            (interactive)
                            (find-file smf/org-input)))

    ;; also, let's turn on auto-fill-mode
    (add-hook 'org-mode-hook 'auto-fill-mode))

  ;; needed for colorizing src blocks
  (use-package htmlize
    :after org
    :ensure t)
#+END_SRC

**** tangling

Straight-up stolen from [[https://git.alanpearce.uk/alan/dotfiles/src/master/tag-emacs/emacs.d/init.org][alan/dotfiles]].

We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code
blocks from the current file into a source-specific file (in this case a
=.el=-file).

To avoid doing this each time a change is made we can add a function to the
=after-save-hook= ensuring to always tangle and byte-compile the =org=-document
after changes.

#+BEGIN_SRC emacs-lisp
  (defun smf/tangle-if-init ()
    "If the current buffer is 'README.org' the code-blocks are
      tangled, and the tangled file is compiled."

    (when (string-suffix-p "README.org" (buffer-file-name))
      (smf/tangle-init)))

  (defun smf/tangle-init-sync ()
    (interactive)
    (message "Tangling init")
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil)
          (src  (expand-file-name "README.org" user-emacs-directory))
          (dest (expand-file-name "init.el"  user-emacs-directory)))
      (require 'ob-tangle)
      (org-babel-tangle-file src dest)
      (if (byte-compile-file dest)
          (byte-compile-dest-file dest)
        (with-current-buffer byte-compile-log-buffer
          (buffer-string)))))

  (defun smf/tangle-init ()
    "Tangle README.org asynchronously."
    (interactive)
    (message "Tangling init")
    (async-start
     (symbol-function #'smf/tangle-init-sync)
     (lambda (result)
       (message "Init tangling completed: %s" result))))

  (add-hook 'after-save-hook #'smf/tangle-if-init)
#+END_SRC

**** org-journal

A great plugin for =org-mode= is =org-journal= to take daily and weekly notes.
I was inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html#org5b9f9d2][Sacha Chau's setup]] (and her [[http://sachachua.com][great website]]) to also revamp my
workflow to use =org-mode= even more better.

So, we'll start with some basic settings,

#+BEGIN_SRC emacs-lisp
  (use-package org-journal
    :after org
    :ensure t
    :defer t
    :config
    (setq-default org-log-done t
                  org-agenda-persistent-filter t
                  org-agenda-sticky t
                  org-enforce-todo-dependencies t
                  org-cycle-separator-lines 0
                  org-blank-before-new-entry (quote ((heading)
                                                     (plain-list-item . auto)))

                  org-journal-dir "~/Dropbox/journal"
                  org-use-fast-todo-selection t
                  org-log-into-drawer t
                  org-log-state-notes-insert-after-drawers nil
                  org-fast-tag-selection-single-key nil
                  org-return-follows-link t
                  org-confirm-babel-evaluate nil

                  org-refile-targets '((org-agenda-files . (:maxlevel . 6)))))
#+END_SRC

The org-protocol plugin is sweet awesomeness. It allows native apps to send
capture notes to Emacs,

#+BEGIN_SRC emacs-lisp
  (use-package org-protocol
    :commands (org-protocol-capture org-protocol-create))
#+END_SRC

**** misc org

Let's use pomodoro!

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :ensure t
    :commands org-pomodoro
    :config
    (setq org-pomodoro-play-sounds nil))
#+END_SRC

While we're at it, let's add notmuch and twitter bootstrap integration,

#+BEGIN_SRC emacs-lisp
  (use-package org-notmuch
    :after notmuch
    :defer t)
#+END_SRC

** prodigy

Manage external services from within Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package prodigy
    :ensure t
    :init
    (smf/add-launcher "d" 'prodigy)
    :commands (prodigy-start-service prodigy-find-service)
    :config
    ;; start by defining a simple service to run the Mercurial website
    (prodigy-define-service
      :name "Mercurial Website"
      :command "python"
      :args '("hgwebsite.py")
      :cwd "~/projects/hgwebsite"
      :tags '(hg python)
      :port 5000
      :kill-signal 'sigkill
      :kill-process-buffer-on-stop t)

    ;; imapnotify is a node app that fires a program (in our case an elisp
    ;; function) when new mail is received
    (prodigy-define-service
      :name "OfflineIMAP"
      :command "imapnotify"
      :args '("-c" "~/.config/imapnotify.js")
      :tags '(mail node)
      :kill-signal 'sigkill
      :kill-process-buffer-on-stop t
      :init 'offlineimap)

    ;; bitbucket awwwwww yeah
    (prodigy-define-tag
      :name 'bitbucket
      :cwd "~/projects/bitbucket"
      :path `(,(expand-file-name "~/.virtualenvs/bitbucket/bin")
              ,(expand-file-name "~/projects/go/bin"))
      :kill-signal 'sigkill
      :env `(("BB_EMAIL_PASSWORD"
              ,(smf/auth-source-pass "bbtest@farley.io" "mail.farley.io"))
             ("HGRCPATH" ,(expand-file-name "~/projects/bitbucket-etc/hgrc"))
             ("GIT_CONFIG_NOSYSTEM" "1")
             ("PYTHONUNBUFFERED" "1")
             ("DEBUG" "1")
             ("CELERY_RDB_PORT" "6900")
             ("DJANGO_SETTINGS_MODULE" "bitbucket.settings.dev")
             ("LANG" "en_US.UTF-8")
             ("PATH" ,(concat (expand-file-name "~/projects/go/bin") ":"
                              (expand-file-name "~/.virtualenvs/bitbucket/bin") ":"
                              (getenv "PATH")))
             ("VIRTUAL_ENV" ,(expand-file-name "~/.virtualenvs/bitbucket/"))))

    (prodigy-define-service
      :name "Bitbucket Celery"
      :command "python"
      :args '("manage.py" "celeryd" "-l" "DEBUG")
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Django"
      :command "python"
      :url "http://dev.bitbucket.org:8000"
      :args '("manage.py" "runserver")
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Hgweb"
      :command "gunicorn"
      :args '("--config" "conf/gunicorn-bridgehgweb.conf.py"
              "--bind" "localhost:8001"
              "-w" "1"
              "bridgehgweb:application")
      :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_hgweb"))
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Gitweb"
      :command "gunicorn"
      :args '("--config" "conf/gunicorn-gitweb.conf.py"
              "--bind" "localhost:8002"
              "-w" "1"
              "gitweb:application")
      :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_gitweb"))
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Conqserver"
      :command "gunicorn"
      :args '("--config" "conf/gunicorn-conqserver.conf.py"
              "--bind" "localhost:9006"
              "-w" "1"
              "conqserver:application")
      :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_conqserver"))
      :tags '(bitbucket))

    (prodigy-define-service
      :name "Bitbucket Conker"
      :command "conker"
      :cwd "~/projects/go/src/bitbucket.org/bitbucket/conker"
      :tags '(bitbucket)))
#+END_SRC

** Other modes

Emacs comes with hundreds of major and minor modes to do many, many things.
These are the ones I commonly use and have configured.

*** aHg

#+BEGIN_SRC emacs-lisp
  (use-package ahg
    :commands ahg-status
    ;; :ensure t)
    :load-path "~/projects/ahg")
#+END_SRC

*** alert

A Growl-like alerts notifier for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package alert
    :ensure t
    :config
    (setq alert-default-style (if (file-executable-p alert-notifier-command)
                                  'notifier
                                'osx-notifier)))
#+END_SRC

*** anaconda

=anaconda= is an Emacs package to bring powerful Python editing to Emacs. After
trying other major packages (elpy and jedi) I’ve settled on anaconda-mode and
virtualenvwrapper. It provides a nice mix of tweakability and convenience.

anaconda-mode provides code navigation and docs. Additionally, if company-mode
is enabled, company-anaconda will also be enabled.

#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :ensure t
    :diminish anaconda-mode
    :commands (anaconda-mode anaconda-eldoc-mode)
    :bind (:map anaconda-mode-map
                ("M-," . nil)  ; By default, anaconda binds =M-,= to finding
                               ; assignments instead of popping the navigation
                               ; stack (which changed in Emacs 25)
                ("M-." . smf/goto-def-or-dumbjump))
    :init
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
    :config
    ;; need to load this for the xref call in our function below
    (use-package xref)

    ;; After a few levels of indirection, =anaconda= has no hope of finding a symbol's
    ;; definition, so it gives up. In this case, invoking
    ;; `anaconda-mode-find-defintions' will do nothing and show a little error message
    ;; in the echo area. When this happens, of course we still want to find what I'm
    ;; looking for so we define this function:
    (defun smf/goto-def-or-dumbjump ()
      "Go to definition of thing at point or do a dumb-jump-go in
      project if that fails"
      (interactive)
      (xref-push-marker-stack)
      (anaconda-mode-call "goto_definitions"
                          'smf/anaconda-mode-find-definitions-callback))

    (defun smf/anaconda-mode-find-definitions-callback (result)
      "Process find definitions RESULT."
      (let ((old-buffer (current-buffer))
            (old-point (point)))
        (if result
            (progn
              (anaconda-mode-definitions-view result)
              (when (and (eq old-point (point))
                         (equal old-buffer (current-buffer)))
                ;; if we didn't actually jump, then fallback to dumb-jump
                (message nil)             ; clear any failed messages since we're
                                          ; about to try a different jump
                (dumb-jump-go)))
          (dumb-jump-go)))))

  (use-package company-anaconda
    :after (anaconda-mode company-mode)
    :ensure t
    :config (add-to-list 'company-backends 'company-anaconda))
#+END_SRC

Showing the indentation by a vertical highlight line is quite handy for quickly
determining the level of indentation,

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indentation
    :after anaconda
    :ensure t
    :diminish highlight-identation-mode
    :config
    (add-hook 'python-mode-hook 'highlight-indentation-mode))
#+END_SRC

*** anzu

[[https://github.com/syohex/emacs-anzu][anzu]] provides enhancements to =isearch= and related tasks, particularly
providing counts and better replacement visualisation.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure t
    :diminish anzu-mode
    :bind (([remap query-replace] . anzu-query-replace)
           ([remap query-replace-regexp] . anzu-query-replace-regexp))
    :config
    (when (fboundp 'spaceline-install)
      (setq anzu-cons-mode-line-p nil))
    (global-anzu-mode))
#+END_SRC

*** avy

I'm choosing =avy= over =ace-jump-mode= for tighter integration with
=ivy-mode=.

[[https://github.com/abo-abo/avy][avy]] allows one to jump around the buffer to named characters (it's easier to
watch the video on that link than explain).

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("H-;" . avy-goto-char)
           ("H-<return>" . avy-goto-line)
           ("H-'" . avy-goto-word-1)))
#+END_SRC

*** browse-kill-ring

[[https://github.com/browse-kill-ring/browse-kill-ring][browse-kill-ring]] allows one to browse the kill ring history when yanking.

#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :ensure t
    :bind (([remap yank-pop] . browse-kill-ring))
    :config
    ;; make browse-kill-ring act like yank-pop by overwriting the previous yank
    (setq browse-kill-ring-replace-yank t))
#+END_SRC


*** c, c++, and objc

Unfortunately, I don't do as much C programming as I would like but [[https://github.com/Sarcasm/irony-mode][irony-mode]]
seems like it would have been really helpful in the past.

#+BEGIN_SRC emacs-lisp
  (use-package irony
    :ensure t
    :defer t
    :config
    (setq-default c-default-style "linux")

    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'objc-mode-hook 'irony-mode)
    (add-hook 'c++-mode-hook 'rtags-start-process-unless-running)
    (add-hook 'c-mode-hook 'rtags-start-process-unless-running)
    (add-hook 'objc-mode-hook 'rtags-start-process-unless-running)

    ;; replace the `completion-at-point' and `complete-symbol' bindings in
    ;; irony-mode's buffers by irony-mode's function
    (defun smf/irony-mode-hook ()
      (define-key irony-mode-map [remap completion-at-point]
        'irony-completion-at-point-async)
      (define-key irony-mode-map [remap complete-symbol]
        'irony-completion-at-point-async))

    (add-hook 'irony-mode-hook 'smf/irony-mode-hook)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

  (use-package company-irony
    :after (company irony)
    :ensure t
    :defer t
    :config
    (add-to-list 'company-backends '(company-irony-c-headers company-irony)))

  (use-package company-irony-c-headers
    :after company-irony
    :ensure t
    :defer t)

  (use-package irony-eldoc
    :after irony
    :ensure t
    :defer t)

  (use-package flycheck-irony
    :after (flycheck irony)
    :ensure t
    :defer t
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup))

  (use-package rtags
    :after irony
    :ensure t
    :defer t)
#+END_SRC

*** colorize compile buffer

Some compiler output has ansi color, so let's escape that,

#+BEGIN_SRC emacs-lisp
  (use-package ansi-color
    :init
    (setq compilation-scroll-output 't)   ; yes plz

    (defun smf/colorize-compilation ()
      "Colorize from `compilation-filter-start' to `point'."
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region
         compilation-filter-start (point))))

    (add-hook 'compilation-filter-hook 'smf/colorize-compilation))
#+END_SRC

*** company

[[https://github.com/company-mode/company-mode][company-mode]] is a modern and modular completion framework (the other one Emacs
people use is [[http://www.emacswiki.org/emacs/AutoComplete][autocomplete]]. I chose =company= because it's well-maintained and
has better code for integrating with).

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :diminish company-mode
    :config
    (setq company-tooltip-limit 20
          company-idle-delay 0
          company-echo-delay 0
          company-minimum-prefix-length 1
          company-selection-wrap-around t
          company-show-numbers t
          company-tooltip-align-annotations t)

    ;; remove xcode since that seems to be defunct
    (setq company-backends (delete 'company-xcode company-backends))

    ;; remove eclim
    (setq company-backends (delete 'company-eclim company-backends))

    ;; insert unicode math symbols based on the LaTeX command
    (add-to-list 'company-backends 'company-math-symbols-unicode)

    (global-company-mode))
#+END_SRC

**** Emoji

#+BEGIN_SRC emacs-lisp
  (use-package company-emoji
    :after company
    :ensure t
    :config
    (add-to-list 'company-backends 'company-emoji))
#+END_SRC

**** Quickhelp

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :after company
    :ensure t
    :config
    (company-quickhelp-mode t))
#+END_SRC

*** crosshairs

Highlights both the line and the column.

#+BEGIN_SRC emacs-lisp
  (use-package crosshairs
    :ensure t
    :bind (("C-|" . column-highlight-mode))
    :init
    (global-hl-line-mode)
    (global-hl-line-highlight))
#+END_SRC

*** docker

#+BEGIN_SRC emacs-lisp
  (use-package docker
    :ensure t
    :defer t)

  (use-package dockerfile-mode
    :after docker
    :ensure t
    :mode "Dockerfile\\'")
#+END_SRC

*** drag-stuff

Drag stuff around in Emacs with convenient keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package drag-stuff
    :ensure t
    :bind (("M-N" . drag-stuff-down)
           ("M-P" . drag-stuff-up))
    :diminish drag-stuff-mode
    :config
    (drag-stuff-global-mode))
#+END_SRC

*** dtrt-indent

[[https://github.com/jscheid/dtrt-indent][dtrt-indent]] is an Emacs minor mode that guesses the indentation offset
originally used for creating source code files and transparently adjusts the
corresponding settings in Emacs, making it more convenient to edit foreign
files.

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :ensure t
    :defer t
    :diminish dtrt-indent-mode
    :config
    (dtrt-indent-mode))
#+END_SRC

*** dumb jump

Dumb Jump is an Emacs "jump to definition" package with support for multiple
programming languages that favors "just working". This means minimal -- and
ideally zero -- configuration with absolutely no stored indexes (TAGS) or
persistent background processes. Dumb Jump requires at least GNU Emacs 24.4.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :commands dumb-jump-mode
    :init
    (add-hook 'prog-mode-hook #'dumb-jump-mode)
    :config
    (setq dumb-jump-selector 'ivy))
#+END_SRC

*** editorconfig

[[https://github.com/editorconfig/editorconfig-core-c][EditorConfig]] makes it easy to maintain the correct coding style when switching
between different text editors and between different projects.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :ensure t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode))
#+END_SRC

*** eldoc-mode

[[http://www.emacswiki.org/emacs/ElDoc][eldoc-mode]] is a minor mode that displays context-sensitive help when editing
Emacs lisp (eg information about arity of functions). Enable that for
=emacs-lisp-mode=:

#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :bind (:map emacs-lisp-mode-map
                ("C-c C-b" . eval-buffer))
    :config
    (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook #'eldoc-mode)
    (add-hook 'prog-mode-hook #'eldoc-mode))
#+END_SRC

*** emacs-git-messenger

#+BEGIN_SRC emacs-lisp
  (use-package git-messenger
    :ensure t
    :commands git-messenger:popup-message
    :init
    (smf/add-launcher "v" 'git-messenger:popup-message)
    :config
    (setq git-messenger:show-detail 't))
#+END_SRC

*** emmet-mode

Not going to lie. Totally ripped this from [[https://github.com/belak/dotfiles][Kaleb]].

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :after web-mode
    :ensure t
    :config
    (add-hook 'web-mode-hook 'emmet-mode))
#+END_SRC

*** exec-path-from-shell

OS X doesn't use the environment variables available in a shell in a GUI
environment ([[https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/EnvironmentVars.html][more here]]).

Since Emacs runs shell commands regularly it's important that the same =PATH= is
available to my editor as [[https://www.macports.org][MacPorts]] etc. set and use.

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] is a package that copies across =PATH= and other variables
to the Emacs environment.

I only want this to be installed and enabled on OS X.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (eq system-type 'darwin)
    :ensure t
    :config
    (setq exec-path-from-shell-variables '("PATH"  "MANPATH" "SHELL"))
    (exec-path-from-shell-initialize))
#+END_SRC

*** flycheck

[[https://github.com/flycheck/flycheck][flycheck]] is a modern, more easily customisable version of [[http://www.emacswiki.org/emacs/FlyMake][flymake]]. It's used to
perform on-the-fly syntax checking and linting.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :commands flycheck-mode
    :diminish flycheck-mode
    :init
    (add-hook 'prog-mode-hook #'flycheck-mode)
    :config
    (defalias 'flycheck-show-error-at-point-soon 'flycheck-show-error-at-point))
#+END_SRC

*** focus

Dim the font color of text in surrounding paragraphs.

#+BEGIN_SRC emacs-lisp
  (use-package focus
    :ensure t
    :commands focus-mode
    :init
    (smf/add-launcher "f" #'focus-mode))
#+END_SRC

*** function-args

GNU Emacs package for showing an inline arguments hint for the C/C++ function
at point.

#+BEGIN_SRC emacs-lisp
  (use-package function-args
    :ensure t
    :defer t
    :config
    (fa-config-default))
#+END_SRC

*** git-gutter

Emacs port of GitGutter which is Sublime Text Plugin.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :diminish git-gutter-mode
    :config
    (setq git-gutter:handled-backends '(git hg))
    (global-git-gutter-mode))
#+END_SRC

*** gitconfig-mode

A major mode for editing .gitconfig files.

#+BEGIN_SRC emacs-lisp
  (use-package gitconfig-mode
    :ensure t
    :defer t)
#+END_SRC

*** gitignore-mode

A major mode for editing .gitignore files.

#+BEGIN_SRC emacs-lisp
  (use-package gitignore-mode
    :ensure t
    :defer t)
#+END_SRC

*** go-mode

Blergh.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t
    :defer t
    :mode "\\.go\\'"
    :bind (:map go-mode-map
                ("M-." . go-guru-definition)
                ("C-c o" . go-guru-map)))

  (use-package company-go
    :after (go-mode company-mode)
    :ensure t
    :defer t
    :config
    (setq company-go-show-annotation t)
    (add-hook 'go-mode-hook (lambda ()
                              (set (make-local-variable 'company-backends) '(company-go))
                              (company-mode))))

  (use-package go-eldoc
    :ensure t
    :defer
    :init
    (add-hook 'go-mode-hook 'go-eldoc-setup))
#+END_SRC

*** goto-chg

Go to last change in current buffer.

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :ensure t
    :bind (("H-." . goto-last-change)))
#+END_SRC

*** groovy-mode

Why.

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t
    :defer t
    :mode "\\.groovy\\'\\|\\.gradle\\'")
#+END_SRC

*** guide-key

[[https://github.com/kai2nenobu/guide-key][guide-key]] shows a popup help window after a pressing defined keys for a short
delay. We'll also enable it for my [[Launcher keymap]] prefix.

#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :ensure t
    :diminish guide-key-mode
    :config
    (setq guide-key/guide-key-sequence '("C-x C-l" "C-c p" "C-x 4"))
    (guide-key-mode))
#+END_SRC

*** hg-test-mode

A mode for Mercurial test files

#+BEGIN_SRC emacs-lisp
  (use-package hg-test-mode
    :load-path "lisp")
#+END_SRC

*** hideshowvis

Enables collapsable regions and diminish the mode:

#+BEGIN_SRC emacs-lisp
  (use-package hideshowvis
    :ensure t
    :diminish hs-minor-mode
    :config
    (add-hook 'prog-mode-hook #'hideshowvis-enable))
#+END_SRC

*** hl-mode

I originally used fic-mode, but it appears that hl-todo is a little better and
is updated more frequently. This lets us highlight TODO, FIXME, XXX, and other
similar keywords.

#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :ensure t
    :config
    (setq hl-todo-keyword-faces '(("FIXME" . hl-todo)
                                  ("TODO"  . hl-todo)
                                  ("XXX"   . hl-todo)))
    (hl-todo-set-regexp)
    (global-hl-todo-mode))
#+END_SRC

*** hugme

An experimental fork of magit for Mercurial. Most of the things here won't work.

**** Keyboard shortcuts

=hugme-status= is the main command to launch Magit. It's =autoloaded= so I don't
need to load Magit first.

#+BEGIN_SRC emacs-lisp
  (use-package hugme
    :after magit
    :load-path "~/projects/hugme/lisp"
    :mode (("hg-editor-.*\\.txt" . hg-commit-mode)
           ("hg-histedit-.*\\.txt" . hg-histedit-mode))
    :init
    (smf/add-launcher "h" 'hugme-status)
    :config
    ;; hugme settings
    (setq-default
     ;; open hugme status in same window as current buffer
     hugme-status-buffer-switch-function 'switch-to-buffer

     ;; highlight word/letter changes in hunk diffs
     hugme-diff-refine-hunk t

     ;; pop the process buffer if we're taking a while to complete
     hugme-process-popup-time 10

     ;; don't prompt me to confirm a canceled histedit
     hg-histedit-confirm-cancel nil

     ;; shelling out to hg is expensive, so until we use something like the command
     ;; server, set a high-timeout for diffs
     hugme-diff-expansion-threshold 10.0

     ;; definitely need to enable debugging while writing this package
     hugme-hg-debug t

     ;; use ivy for completing things
     hugme-completing-read-function 'ivy-completing-read

     ;; experimentally try to use chg, though it doesn't seem to improve the
     ;; speed of shelling out
     hugme-hg-executable "chg"))
#+END_SRC

*** hungry-delete

=hungry-delete= will delete all whitespace forward or backward.

#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :bind (("H-<backspace>" . hungry-delete-backward)
           ("H-d" . hungry-delete-forward)))
#+END_SRC

*** js2-mode

Improved JavaScript editing mode for GNU Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :defer t
    :mode "\\.js\\'"
    :config
    (setq js2-basic-offset 2)
    (when (fboundp 'flycheck-mode)
      (set-face-attribute 'js2-error nil
                          :inherit 'flycheck-error-list-error
                          :underline '(:color foreground-color :style wave))
      (set-face-attribute 'js2-warning nil
                          :inherit 'flycheck-error-list-warning
                          :underline '(:color foreground-color :style wave))))
#+END_SRC

*** json-mode

Sure, why not.

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :defer t
    :mode "\\.json\\'"
    :config
    (setq json-reformat:indent-width 2))
#+END_SRC

*** less-css-mode

=less-css-mode= is a major mode for Emacs which displays strings representing
colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (use-package less-css-mode
    :ensure t
    :commands less-css-mode)
#+END_SRC

*** lua-mode

Dear god.

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :ensure t
    :defer t
    :mode "\\.lua\\'")

  (use-package company-lua
    :after lua
    :ensure t
    :defer t)
#+END_SRC

*** magit

[[https://github.com/magit/magit][Magit]] is an Emacs interface to Git. It's very feature-rich and I find it
intuitive.

**** Keyboard shortcuts

=magit-status= is the main command to launch Magit. It's =autoloaded= so I don't
need to load Magit first.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :commands (magit-status magit-commit magit-log-mode)
    :mode ("COMMIT_EDITMSG" . git-commit-mode)
    :init
    (smf/add-launcher "g" 'magit-status)
    :config
    ;; magit settings
    (setq-default
     ;; open the =magit-status= buffer in the same window as the current buffer
     magit-status-buffer-switch-function 'switch-to-buffer

     ;; highlight individual word and letter changes when showing hunk diff overlays
     magit-diff-refine-hunk t

     ;; pop the process buffer if we're taking a while to complete
     magit-process-popup-time 10

     ;; ugh, stupid git
     git-commit-summary-max-length 72

     ;; ask me if I want a tracking upstream
     magit-set-upstream-on-push 'askifnotset

     ;; always show the diff in commit window
     magit-commit-arguments '("--verbose")

     ;; use ivy for completing things
     magit-completing-read-function 'ivy-completing-read))
#+END_SRC

*** markdown-mode

[[http://melpa.milkbox.net/#/markdown-mode][markdown-mode]] is a major mode for editing Markdown files.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode ("\\.md\\'" . gfm-mode)
    :config
    (define-key markdown-mode-map (kbd "<M-left>") nil)
    (define-key markdown-mode-map (kbd "<M-right>") nil))
#+END_SRC

*** move-text

#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    :config
    (move-text-default-bindings))
#+END_SRC

*** multiple cursors

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind ("H-n" . mc/mark-next-like-this)
          ;; ("s-n" . mc/skip-to-next-like-this)
          ("H-p" . mc/mark-previous-like-this)
          ;; ("s-p" . mc/skip-to-previous-like-this)
          ("H-l" . mc/mark-all-symbols-like-this)
          ("C-S-<mouse-1>" . mc/add-cursor-on-click))
#+END_SRC

*** narrow-indirect

[[http://www.emacswiki.org/emacs/narrow-indirect.el][narrow-indirect]] allows one to focus a buffer onto some particular code in
another window, editing it separately from its original context ([[http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/][a better
description of this workflow]]).

#+BEGIN_SRC emacs-lisp
  (use-package narrow-indirect
    :ensure t)
#+END_SRC

*** paradox

[[https://github.com/Bruce-Connor/paradox][paradox]] is an advanced package.el frontend with GitHub integration. Paradox
[[https://github.com/Bruce-Connor/paradox/commit/e341a900609974802ad92d5bb43083fcf83ef432#diff-2d43bf4d9c7b9686d0895974900dfd05R18][supports an asynchronous mode]] which requires the =async= package, so we'll load
this after async.

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :ensure t
    :commands paradox-list-packages
    :init
    (smf/add-launcher "p" 'paradox-list-packages)
    :config
    (setq paradox-automatically-star t
          paradox-execute-asynchronously t))
#+END_SRC

*** persistent =*scratch*= buffer

Emacs has a handy, but sometimes decried, feature called the "scratch" buffer.
One problem with =*scratch*= is that its tempting to put significant bits of
code (and other information) into it.

For some reason, this needs to be loaded after anzu else the =*scratch*= buffer
will have whitespace symbols.

#+BEGIN_SRC emacs-lisp
  (use-package persistent-scratch
    :ensure t
    :config
    (persistent-scratch-setup-default)
    (persistent-scratch-autosave-mode))
#+END_SRC

*** pip

This adds some basic features for requirements files, such as highlighting and
auto-completion of names from PyPI.

#+BEGIN_SRC emacs-lisp
  (use-package pip-requirements
    :ensure t
    :mode (("requirements.*\\.txt" . pip-requirements-mode)))
#+END_SRC

*** popwin

[[https://github.com/m2ym/popwin-el][popwin]] is a popup window manager that helps make the behaviour of compilation
buffers, search buffers etc. a bit more sane.

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :ensure t
    :bind (("C-c P" . popwin:popup-last-buffer))
    :config
    ;; also add ag, flycheck, and occur to pop
    (add-to-list 'popwin:special-display-config `"*ag search*")
    (add-to-list 'popwin:special-display-config `"*ripgrep-search*")
    (add-to-list 'popwin:special-display-config `"*Flycheck errors*")
    (add-to-list 'popwin:special-display-config `"*Occur*")

    ;; don't auto-select the compile process buffer as it's only for information
    (add-to-list 'popwin:special-display-config `("*Compile-Log*" :noselect t))

    ;; enable
    (popwin-mode))
#+END_SRC

*** projectile

[[https://github.com/bbatsov/projectile][projectile]] is a minor mode for performing commands over a single 'project' or
grouping of files.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :defer 4
    :init
    (smf/add-launcher "s" 'projectile-switch-project)
    :config
    (setq projectile-completion-system 'ivy
          projectile-enable-caching t)
    (projectile-mode))
#+END_SRC

*** projectile ripgrep

Set up some key bindings:

#+BEGIN_SRC emacs-lisp
  (use-package projectile-ripgrep
    :ensure t
    :bind (([remap projectile-grep] . projectile-ripgrep)))
#+END_SRC

*** puppet-mode

[[https://github.com/lunaryorn/puppet-mode][puppet-mode]] is a major mode for editing =.pp= files.

#+BEGIN_SRC emacs-lisp
  (use-package puppet-mode
    :ensure t
    :disabled)
#+END_SRC

*** python debugger

#+BEGIN_SRC emacs-lisp
  (use-package realgud
    :ensure t
    :disabled t
    :bind (:map realgud:shortkey-mode-map
                ([mouse-3] . realgud:tooltip-eval)
                :map realgud-track-mode-map
                ("C-c C-/" . realgud:ipdb-foo)))
#+END_SRC

*** python-mode

As of 24.2, Emacs ships with a [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs#toc1][robust Python mode]]. However, when navigating
=SnakeCase= words (eg class names), =forward-word= etc don't work correctly.

We can work around that using [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html#Subword-Movement][subword-mode]]:

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode)
    :config
    (add-hook 'python-mode-hook #'subword-mode))
#+END_SRC

*** python-switch-quotes

Cycle between apostrophes and quotes in python strings. Converts strings like
'this' to strings like "this".

#+BEGIN_SRC emacs-lisp
  (use-package python-switch-quotes
    :after python
    :ensure t
    :defer t
    :bind (:map python-mode-map
                ("C-c '" . python-switch-quotes)))
#+END_SRC

*** rainbow-blocks

=rainbow-blocks= is an Emacs mode that highlights blocks made of parentheses,
brackets, and braces according to their depth.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-blocks
    :ensure t
    :diminish rainbow-blocks-mode
    :commands rainbow-blocks-mode
    :init
    (add-hook 'emacs-lisp-mode-hook #'rainbow-blocks-mode)
    (add-hook 'lisp-interaction-mode-hook #'rainbow-blocks-mode))
#+END_SRC

*** rainbow-delimiters

=rainbow-delimiters= is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their depth.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** rainbow-mode

=rainbow-mode= is a minor mode for Emacs which displays strings representing
colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-mode
    :init
    (add-hook 'prog-mode-hook #'rainbow-mode))
#+END_SRC

*** recentf

[[http://www.emacswiki.org/emacs/RecentFiles][recentf]] stores a list of recently opened files. The list of files contains any
files Emacs has read, not just files I've explicitly opened. Clean that list to
exclude Emacs metafiles, package cruft etc.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    ;; never clean up the list:
    (setq recentf-auto-cleanup 'never
          recentf-max-saved-items 500
          recentf-max-menu-items 15

          ;; customize the place =recentf= persists its list of items:
          recentf-save-file (expand-file-name ".recentf"
                                              smf/tmp-local-dir))

    ;; strip =$HOME= from the front of =recentf= candidate files
    (add-to-list 'recentf-filename-handlers 'abbreviate-file-name)

    (add-to-list 'recentf-exclude "[/\\]\\.elpa/")
    (add-to-list 'recentf-exclude "[/\\]\\.ido\\.last\\'" )
    (add-to-list 'recentf-exclude "[/\\]\\.git/")
    (add-to-list 'recentf-exclude ".*\\.gz\\'")
    (add-to-list 'recentf-exclude ".*-autoloads\\.el\\'")
    (add-to-list 'recentf-exclude "[/\\]archive-contents\\'")
    (add-to-list 'recentf-exclude "[/\\]\\.loaddefs\\.el\\'")
    (add-to-list 'recentf-exclude "url/cookies")
    (add-to-list 'recentf-exclude ".*\\emacs.bmk\\'")
    (add-to-list 'recentf-exclude "README\\.el\\'")
    (add-to-list 'recentf-exclude "/custom\\.el\\'")

    (recentf-mode))
#+END_SRC

*** ripgrep

[[https://github.com/nlamirault/ripgrep.el][ripgrep]] is an Emacs frontend to [[https://github.com/BurntSushi/ripgrep][the rg command]], a grep-like code-searching tool. It's
installed via cargo on my Mac.

#+BEGIN_SRC emacs-lisp
  (use-package ripgrep
    :ensure t
    :commands ripgrep-regexp
    :if (executable-find "rg"))
#+END_SRC

*** ruby-mode

As of 24.4, Emacs comes with a much better [[http://www.masteringemacs.org/articles/2013/12/29/whats-new-in-emacs-24-4/][Ruby mode]]. However it doesn't come
with =subword-mode= enabled by default:

#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :mode "\\.rb\\'"
    :interpreter "ruby"
    :config
    (add-hook 'ruby-mode-hook #'subword-mode))
#+END_SRC

*** rust-mode

=rust-mode= makes editing Rust code with Emacs enjoyable.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :mode "\\.rs\\'")

  (use-package racer
    :after rust-mode
    :ensure t
    :config
    (setq racer-rust-src-path "/opt/local/share/rust/src/")
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode))

  (use-package flycheck-rust
    :after (rust-mode flycheck-mode)
    :ensure t
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC

*** sh-script

I have a few files in my dotfiles repo that are known to be shell files, so
let's add them:

#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :mode ((".?aliases" . sh-mode)
           (".?bash_prompt" . sh-mode)
           (".?bashrc" . sh-mode)
           (".?exports" . sh-mode)
           (".?functions" . sh-mode)
           (".?osx" . sh-mode)
           (".?profile" . sh-mode)
           (".?hgrc" . conf-mode)))
#+END_SRC

*** skewer-mode

[[https://github.com/skeeto/skewer-mode][Skewer]]: live web development with Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package skewer-mode
    :ensure t
    :defer t)
#+END_SRC

*** slime-nav

Slime allows very convenient navigation to the symbol at point (using M-.), and
the ability to pop back to previous marks (using =M-,=).

This plugin provides similar navigation for Emacs Lisp, supporting navigation
to the definitions of variables, functions, libraries and faces.

#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :ensure t
    :diminish elisp-slime-nav-mode
    :init
    (add-hook 'emacs-lisp-mode-hook 'elisp-slime-nav-mode)
    (add-hook 'ielm-mode-hook 'elisp-slime-nav-mode))
#+END_SRC

*** smart-tabs-mode

This mode provides code which improves on Emacs’ auto-indenting, so that
whenever you press the <tab> key, the appropriate amount of tabs and spaces is
inserted automatically. You can still use all spaces if you prefer, of course;
the code merely ensures that if you enable tabs (maybe when maintaining legacy
code), the tab size does not matter.

#+BEGIN_SRC emacs-lisp
  (use-package smart-tabs-mode
    :ensure t
    ;; enable smart-tabs-mode automatically for C and Javascript
    :config
    (smart-tabs-insinuate 'c 'javascript))
#+END_SRC

*** smartparens

[[https://github.com/Fuco1/smartparens][smartparens]] is a =paredit= like minor-mode for many more things than just Lisp.

=show-smartparens-mode= is a replacement mode for =show-paren-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :commands smartparens-mode
    :init
    (add-hook 'prog-mode-hook #'smartparens-mode)
    :config
    (use-package smartparens-config))
#+END_SRC

*** smex

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :commands (smex smex-update smex-initialize)
    :config
    (setq smex-auto-update nil)
    (defun smex-update-after-load (_unused)
      (if (boundp 'smex-cache)
          (smex-update)))
    (add-hook 'after-load-functions 'smex-update-after-load)
    :init
    (setq smex-history-length 32
          smex-save-file (expand-file-name ".smex-items"
                                           smf/tmp-local-dir)))
#+END_SRC

*** sphinx-doc-mode

[[https://github.com/naiquevin/sphinx-doc.el][sphinx-doc]] is an emacs minor mode for inserting docstring skeleton for Python
functions and methods.

#+BEGIN_SRC emacs-lisp
  (use-package sphinx-doc
    :ensure t
    :diminish sphinx-doc-mode
    :config
    (add-hook 'python-mode-hook 'sphinx-doc-mode))
#+END_SRC

*** swiper / ivy

Ivy - a generic completion frontend for Emacs, Swiper - isearch with an
overview, and more. [[http://oremacs.com/swiper][Oh, man!]]

Note: swiper <- {counsel, ivy}

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind (("C-s" . swiper)
           ("s-f" . swiper)))

  (use-package counsel
    :ensure t
    :commands (counsel-M-x counsel-find-file counsel-describe-function
               counsel-describe-variable counsel-unicode-char)
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("<f1> f" . counsel-describe-function)
           ("<f1> v" . counsel-describe-variable)
           ("M-y" . counsel-yank-pop))
    :init
    (smf/add-launcher "U" 'counsel-unicode-char)
    (smf/add-launcher "i" 'counsel-imenu))

  (use-package ivy
    :ensure t
    :demand t
    :diminish ivy-mode
    :bind (("C-c C-r" . ivy-resume)         ; resumes the last Ivy-based completion
           ("C-x b" . ivy-switch-buffer)    ; use this instead of the lackluster
                                            ; `list-buffers'
           ("C-x C-b" . ivy-switch-buffer)  ; common typo
           ("C-x C-n" . ivy-switch-buffer)) ; common typo
    :config
    (setq ivy-wrap t                        ; wraps around the buffer
          ivy-initial-inputs-alist nil      ; don't insert '^'
          ivy-use-virtual-buffers t)
    (ivy-mode))
#+END_SRC

*** tern

=tern= is a js navigation package which extends js-mode.

#+BEGIN_SRC emacs-lisp
  (use-package tern
    :ensure t
    :defer t
    :diminish tern-mode
    :config
    (add-hook 'js-mode-hook (lambda () (tern-mode t))))

  (use-package company-tern
    :after (tern company-mode)
    :ensure t
    :defer t
    :config
    (add-to-list 'company-backends 'company-tern)
    (setq company-tern-property-marker ""))
#+END_SRC

*** tramp mode

=tramp-mode= is a package that provides [[https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top][remote file editing]], eg =find-file
/user@host:file=. This allows one to edit files on other servers using your
local Emacs (rather than the Vim user's equivalent of editing the file on the
server).

First we set the default mode to be =ssh= (it's normally =scp=). There are two
reasons for this choice:

- =ssh= takes a port number as an argument, whereas =scp= doesn't
- It's [[http://www.gnu.org/software/tramp/#Default-Method][apparently faster]] for smaller files

We also want to alter the list of allowed proxies (tramp uses a whitelist for
patterns that it can remotely access) so I can edit remote files as sudo, eg
=find-file /sudo:example.com/etc/something-owned-by-root=.

I got this code from the [[http://www.gnu.org/software/tramp/#Multi_002dhops][Multi-hops section of the tramp manual]].

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :config
    (add-to-list 'tramp-default-proxies-alist
                 '(nil "\\`root\\'" "/ssh:%h:"))

    ;; also make sure we can edit local files as sudo - this is normally
    ;; disallowed for security reasons
    (add-to-list 'tramp-default-proxies-alist
                 '((regexp-quote (system-name)) nil nil))

    (setq tramp-default-method "ssh"
          tramp-ssh-controlmaster-options (concat "-o ControlPath=/tmp/tramp.%%r@%%h:%%p "
                                                  "-o ControlMaster=auto "
                                                  "-o ControlPersist=no")))
#+END_SRC

More on the last two incantations at [[http://emacs-fu.blogspot.co.uk/2009/10/editing-files-owned-by-root.html][emacs-fu's guide to editing files owned by root]].

*** twitter

=Twittering-mode=: a Twitter client for Emacs

#+BEGIN_SRC emacs-lisp
  (use-package twittering-mode
    :ensure t
    :defer t
    :commands twit
    :init
    (smf/add-launcher "t" 'twit)
    :config
    (setq twittering-icon-mode t)
    (setq twittering-use-icon-storage t))
#+END_SRC

*** undo-tree

[[http://www.dr-qubit.org/undo-tree/undo-tree.el][undo-tree-mode]], a mode which allows one to visualise their undo/redo history:

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :bind (("C-x u" . undo-tree-visualize)
           ("s-z" . undo-tree-undo)
           ("s-Z" . undo-tree-redo))
    :config
    (global-undo-tree-mode))
#+END_SRC

*** volatile highlights

Minor mode for visual feedback on some operations in Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package volatile-highlights
    :ensure t
    :diminish volatile-highlights-mode
    :config
    (volatile-highlights-mode))
#+END_SRC

*** web-mode

[[https://github.com/fxbois/web-mode][web-mode]] is a major mode for editing templates and HTML. It supports a very
broad range of template languages and is highly configurable.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    "\\.erb\\'"
    "\\.html\\'"
    "\\.jinja\\'"
    "\\.mustache\\'"
    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2))
#+END_SRC

*** whitespace-mode

I like whitespace-mode for programming and text modes (including org),

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :commands whitespace-mode
    :init
    (add-hook 'text-mode-hook #'whitespace-mode)
    (add-hook 'prog-mode-hook #'whitespace-mode)
    (add-hook 'org-mode-hook #'whitespace-mode)
    :config
    ;; most of the time we only want to see tabs and trailing spaces
    (setq whitespace-style '(trailing face tabs tab-mark lines-tail))
    (setq whitespace-display-mappings '((space-mark 32 [183] [46])
                                        (newline-mark 10 [182 10])
                                        (tab-mark 9 [9655 9] [92 9]))))
#+END_SRC

*** whole line or region

It's very convenient to select the whole line when no region is active.

#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
    :ensure t
    :diminish whole-line-or-region-mode
    :config
    (whole-line-or-region-mode))
#+END_SRC

*** yaml-mode

Regrettably I need to occasionally edit [[http://www.yaml.org][YAML]].

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode "\\.yml\\'")
#+END_SRC

*** yasnippet

YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates. Bundled language templates
include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more. The
snippet syntax is inspired from [[http://manual.macromates.com/en/snippets][TextMate's]] syntax.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :commands (yas-global-mode yas-minor-mode)
    :diminish yas-minor-mode
    :init
    (add-hook 'prog-mode-hook #'yas-minor-mode)
    :config
    (setq yas/root-directory (smf/join-dirs smf/dotfiles-dir "snippets"))
    (yas-reload-all))
#+END_SRC

** Local and custom configuration

*** Local overrides

So I can configure my Emacs per computer/user, I attempted to automatically load
some configuration.

First set up a directory to hold the files:

#+BEGIN_SRC emacs-lisp
  (defvar smf/local-dotfiles-dir (smf/join-dirs smf/dotfiles-dir "local"))
#+END_SRC

Now try to load a file named after the current user:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir user-login-name ".el") t)
#+END_SRC

and try to load a file named after the local system:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir (system-name) ".el") t)
#+END_SRC

Finally, try loading a default file:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir "local-overrides.el") t)
#+END_SRC

*** =Customize=-d configuration

Make sure anything saved using =customize= goes into a consistent (and ignored)
place:

#+BEGIN_SRC emacs-lisp
  (load (setq custom-file (concat smf/dotfiles-dir "custom.el")) t)
#+END_SRC

(note that this works because =setq= returns the value it's set to)
