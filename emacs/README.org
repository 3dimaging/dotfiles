* Sean Farley's Emacs Configuration

** Preamble

As my editor of choice I run Emacs. One of the benefits of Emacs is
that it'll install basically anywhere.

This configuration is designed to run in shells as well as on
desktops. There are some platform specific optimisations as well.

This excellent configuration was forked from [[https://github.com/bradleywright/emacs.d][Bradley Wright]].

*** What is this?

It's built using [[http://orgmode.org][Org mode]]'s [[http://orgmode.org/manual/Extracting-source-code.html#Extracting-source-code][tangling functionality]].

My entire Emacs configuration is thus written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style,
and is contained entirely in this file.

*** Installing

Just check it out straight to the right directory, and use Make to
install it:

: cd ~/Projects/emacs.d && make

*** Platform specific configuration

**** OS X desktop (Emacs.app)

- Left =option= key is remapped to =M-=
- We use the [[https://github.com/bbatsov/solarized-emacs][Solarized Dark]] theme
- Font is [[https://github.com/Lokaltog/powerline-fonts/tree/master/SourceCodePro][Source (Sauce) Code Pro]]

**** OS X CLI in iTerm2

- When the [[https://github.com/altercation/solarized/blob/master/iterm2-colors-solarized/Solarized%20Dark.itermcolors][Solarized Dark iTerm2 theme]] is installed, we use the
  =solarized-dark= color theme
- Cut/paste are made to write/read from the clipboard (via =pbcopy=
  and =pbpaste=)
- Mouse highlighting works via xTerm capabilities

***** Required iTerm 2 Configuration

     - Re-map left =option= key to =+Esc=
     - Untick =Smart cursor color=

*** Included libraries

The following libraries are included in non-attributable ways, i.e not
via package install or via a Git submodule:

- [[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]] was a very big early influence, and continues to
  be helpful.

*** License and copyright

Copyright 2010 Bradley Wright.
Copyright 2014 Sean Farley.

Files are licensed under the same license as Emacs (GPL) unless
otherwise specified. See the =COPYING= file for more information.

Any external/third party works included in this work are licensed under
their own licenses - refer to the submodules or packages for more
information.

** Conventions

Functions and variables defined exclusively for my use are prefixed with my
initials and a slash =smf/= to namespace them.

** Setup

Emacs looks in [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Loading-Files.html][load-path]] for Emacs lisp files. =require= and other loading
constructs use this when looking for implicit names.

First we define a convenience function =smf/add-to-load-path= that adds the
passed in directory to =load-path=:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-to-load-path (dir)
    "Adds `dir' to load-path"
    (add-to-list 'load-path dir))
#+END_SRC

and a convenience function for making a proper path out of two strings:

[[file:init.el::(defun%20smf/join-dirs%20(prefix%20suffix][see init.el for code]].

*** use-package

I guess it's time to use this now.

#+BEGIN_SRC emacs-lisp
  (require-package 'use-package)
#+END_SRC

*** Base load path

Define a base directory =smf/dotfiles-dir= that's relative to the currently
loading file (this file). This means if I deliberately start Emacs with a file
loaded:

#+BEGIN_SRC
$ emacs -q -l ~/src/emacs/init.el
#+END_SRC

then =smf/dotfiles-dir= will be =~/src/emacs=. [[file:init.el::(defconst%20smf/dotfiles-dir][See init.el for code]].

This variable is important because all other directories I load things from are
relative to it, which means my Emacs config doesn't need to live in
=user-emacs-directory=.

*** Temporary directory

Emacs has many packages which need to store state in files. Generally these are
in =~= or =user-emacs-directory= - since my entire =~/.emacs.d= is versioned,
I'd rather all temporary files were stored in a known place, =smf/tmp-local-dir=.
This directory is created if it doesn't exist.

#+BEGIN_SRC emacs-lisp
  (make-directory
   (setq smf/tmp-local-dir
         (smf/join-dirs smf/dotfiles-dir ".tmp")) t)
#+END_SRC

*** Backups

Emacs automatically [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Backup.html][backs up files]] while you're editing them. The default
configuration isn't great though.

First, set up some directories to keep backups:

#+BEGIN_SRC emacs-lisp
  (make-directory
   (setq smf/tmp-backups-dir
         (smf/join-dirs smf/tmp-local-dir "backups")) t)
  (make-directory
   (setq smf/tmp-autosaves-dir
         (smf/join-dirs smf/tmp-local-dir "autosaves")) t)
#+END_SRC

Now use those directories for backups and autosave files:

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `((".*" . ,smf/tmp-backups-dir))
        auto-save-file-name-transforms `((".*" ,smf/tmp-autosaves-dir)))
#+END_SRC

Always copy files when backing up to avoid breaking symlinks:

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t)
#+END_SRC

Delete old versions automatically, and keep a limited number around:

#+BEGIN_SRC emacs-lisp
  (setq delete-old-versions t
        kept-new-versions 2
        kept-old-versions 2)
#+END_SRC

Finally, use version numbers in the filenames:

#+BEGIN_SRC emacs-lisp
  (setq version-control t)
#+END_SRC

** =after-load=

First let's define a convenient macro that wraps typical =eval-after-load= in
such a way that we don't need to use =progn= to contain the callback logic. This
macro was gotten from [[https://github.com/purcell/emacs.d/blob/aa789c9745b13612c4fea6e638d81d8ebbfecdf8/init-utils.el#L1-L5][Steve Purcell's emacs.d repo]]:

#+BEGIN_SRC emacs-lisp
  (defmacro after-load (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
       '(progn ,@body)))
#+END_SRC

** Client/server

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server][client/server]] model for editing. The client is invoked via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Invoking-emacsclient.html][the
=emacsclient= command]]. More information on configuration is available on the
[[http://www.emacswiki.org/emacs/EmacsClient][EmacsWiki EmacsClient page]].

We make sure the server is running, additionally guarded to check if the version
of Emacs we're using supports the server package:

#+BEGIN_SRC emacs-lisp
  (setq server-use-tcp t)
  (when (require 'server nil t)
    (unless (server-running-p)
      (server-start)))
#+END_SRC

** Editing defaults

Emacs comes with a collection of strange defaults. See [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's
=sane-defaults.el= file]] for some commentary.

*** Line widths and wrapping

The default wrap width (known as [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Filling.html][filling]]) for Emacs is 70 characters. Modern
conventions state that 80 characters is the standard:

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 79)
#+END_SRC

I don't type double-space sentences, so make sure that Emacs doesn't look for
double-spaces after periods to fill paragraphs correctly:

#+BEGIN_SRC emacs-lisp
  (setq-default sentence-end-double-space nil)
#+END_SRC

*** Trailing whitespace

Most UNIX tools work best when there's a trailing newline on all files. Enable
that option:

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

Emacs has lots of other options for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Useless-Whitespace.html][managing superfluous whitespace]].

*** Indentation

I don't use tabstops in files, and my default tab width is 4 characters.

It's worth noting that Emacs can override either of those on a per-file/mode
basis, so Makefiles, Ruby etc. will still get the correct indentation rules.

#+BEGIN_SRC emacs-lisp
  (setq-default
   indent-tabs-mode nil
   tab-width 2
   tab-stop-list (number-sequence 2 120 2)
   sh-basic-offset 2
   sh-indentation 2
   c-basic-offset 2
   web-mode-code-indent-offset 2
   web-mode-markup-indent-offset 2
   web-mode-css-indent-offset 2
   web-mode-sql-indent-offset 2)
#+END_SRC

**** Auto-indentation

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Indent-Convenience.html][Electric indent mode]] was added in Emacs 24.1, and it enables automatic indentation when typing a newline. [[http://emacsredux.com/blog/2013/03/29/automatic-electric-indentation][More about electric indent mode on Emacs Redux]].

First we define convenience toggling functions we can use in a hook (or interactively):

#+BEGIN_SRC emacs-lisp
  (defun smf/turn-on-electric-indent-mode ()
    "Turns on electric-indent-mode"
    (interactive)
    (electric-indent-mode 1))

  (defun smf/turn-off-electric-indent-mode ()
    "Turns off electric-indent-mode"
    (interactive)
    (electric-indent-mode -1))
#+END_SRC

then we enable it for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Program-Modes.html][the generic abstract programming mode =prog-mode=,
introduced in Emacs 24.1]] ([[http://emacsredux.com/blog/2013/04/05/prog-mode-the-parent-of-all-programming-modes/][more about =prog-mode= on Emacs Redux]]):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'smf/turn-on-electric-indent-mode)
#+END_SRC

*** Encoding

I want to have [[http://en.wikipedia.org/wiki/UTF-8][UTF-8]] by default. [[http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/][Emacs unfortunately has a few settings that
govern encoding]], so we should set them all at once:

#+BEGIN_SRC emacs-lisp
  ;; Utf-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
  (setenv "LANG" "en_US.ut8") ; ensure subprocesses get the right env variable
#+END_SRC

*** Smart =beginning-of-line=

=C-a= is mapped to =beginning-of-line= by default, which moves point to position
0 on the current line. [[http://irreal.org/blog/?p=1946][The irreal blog suggests a smarter alternative]] that moves
the point to the first non-whitespace character first, and then position 0, with
extra presses toggling the position:

#+BEGIN_SRC emacs-lisp
  (defadvice move-beginning-of-line (around smarter-bol activate)
    ;; Move to requested line if needed.
    (let ((arg (or (ad-get-arg 0) 1)))
      (when (/= arg 1)
        (forward-line (1- arg))))
    ;; Move to indentation on first call, then to actual BOL on second.
    (let ((pos (point)))
      (back-to-indentation)
      (when (= pos (point))
        ad-do-it)))
#+END_SRC

This functionality uses the Emacs concept of [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][advice]], which is a way of modifying
existing functions in-place without redefining the entire thing.

*** Fix minibuffer behaviour

When changing focus to the minibuffer, stop allowing point to move over the
prompt. Code taken from [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][ergoemacs]].

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'minibuffer-avoid-prompt))
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'point-entered))
#+END_SRC

While we're at it, let's allow recursive minibuffers.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

Also, let's save the minibuffer history between sessions. It's 2014. We have the
technology.

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)
  (setq history-length 1000)
#+END_SRC

*** Deleting files

Move files to the trash when deleting:

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

*** Compressed files

Transparently open compressed files:

#+BEGIN_SRC emacs-lisp
  (auto-compression-mode t)
#+END_SRC

*** Active region

Got these from [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's =sane-defaults.el=]]. Show the active region,

#+BEGIN_SRC emacs-lisp
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)
#+END_SRC

Remove text in active region if inserting text,

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** Pop mark

When popping the mark, continue popping until the cursor actually moves. Also,
if the last command was a copy - skip past all the expand-region cruft.

#+BEGIN_SRC emacs-lisp
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (when (eq last-command 'save-region-or-current-line)
        ad-do-it
        ad-do-it
        ad-do-it)
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+END_SRC

*** Window mark

If this is true, then [[erc]]'s scrolling is broken.

#+BEGIN_SRC emacs-lisp
  (setq switch-to-buffer-preserve-window-point nil)
#+END_SRC

** Keyboard

*** Modifier keys

- =C-= means =Control= in combination with another key, eg =C-x= means =Ctrl + x=
- =M-= means =Meta= in combination with another key. This is usually =Alt=, or
  =⌘= on OS X (by default). =Esc= also serves as =Meta= if it's not separately
  bound. On OS X I want to use left =⌥= for =Meta=, and leave right =⌥= alone:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-alternate-modifier 'meta)
    (setq mac-option-modifier 'meta)
    (setq ns-right-alternate-modifier nil))
#+END_SRC

- =s-= means [[http://en.wikipedia.org/wiki/Super_key_(keyboard_button)][super key]]. On OS X I want this to be =⌘=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-command-modifier 'super)
    (setq mac-command-modifier 'super)) ;; for EmacsMac.app
#+END_SRC

- =H-= means [[http://en.wikipedia.org/wiki/Hyper_key][hyper key]]. On OS X I want this to be =fn=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-function-modifier 'hyper)
    (setq mac-function-modifier 'hyper)) ;; for EmacsMac.app
#+END_SRC

*** Basic remappings

The below are some remappings I got from [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge's Effective Emacs]] article.
They're designed to map some slightly difficult but very common mappings to
things that are easier to type.

**** Prefer =backward-kill-word= over Backspace

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item3][Yegge's Item 3]]. This emulates readline =C-w= command to
=backward-kill-word=. The command that used to live there (=kill-region=) is not
needed since the backspace key works just fine in that case.

#+BEGIN_SRC emacs-lisp
  ;; deletes backward until a space is hit
  (defun smf/backward-kill-word ()
    (interactive)
    (if (and transient-mark-mode mark-active)
        (kill-region (point) (mark))
      (progn
        (delete-region (point) (save-excursion (skip-syntax-backward " ") (point)))
        (delete-region (point) (save-excursion (skip-syntax-backward "^ ") (point))))))

  (global-set-key (kbd "C-w") 'smf/backward-kill-word)
#+END_SRC

**** Quick window switching

Usually one must type =C-x o= to switch between windows - make that quicker by
also mapping =M-o=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-o") 'other-window)
  ;; Moving between windows
  (global-set-key (kbd "C-s-<up>") 'windmove-up)
  (global-set-key (kbd "C-s-<down>") 'windmove-down)
  (global-set-key (kbd "C-s-<right>") 'windmove-right)
  (global-set-key (kbd "C-s-<left>") 'windmove-left)
#+END_SRC

**** Buffer management

Add a key combination to revert the current buffer (re-read the contents from
disk):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC

Most of the time I want the buffer to be reverted automatically:

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

Use =ivy-switch-buffer= instead of the feature-lacking =list-buffers= (and
include a common typo I make):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ivy-switch-buffer)
  (global-set-key (kbd "C-x C-n") 'ivy-switch-buffer)
#+END_SRC

**** Increase / decrease font size

I never remember the keybindings for this:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-=") 'text-scale-increase)
  (global-set-key (kbd "s--") 'text-scale-decrease)
  (global-set-key (kbd "s-0") '(lambda () (interactive) (text-scale-adjust 0)))
#+END_SRC

*** Launcher keymap

This trick I got from [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][a blog post on launcher keymaps]]. I define my launcher
combo as =C-x C-l=, which is normally =downcase-region= - a command I use so
infrequently I didn't even know there was a key binding for it.

#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'smf/launcher-map)
  (define-key ctl-x-map (kbd "C-l") 'smf/launcher-map)
#+END_SRC

rather than remembering that it's =smf/launcher-map=, just make a function:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-launcher (key function)
    "Maps FUNCTION to KEY under the `smf/launcher-map' prefix"
    (define-key smf/launcher-map key function))
#+END_SRC

** Interface

*** Remove chrome

To ensure that all scrollbars, toolbars etc. are turned off, we run this as
early as possible.

#+NAME: turn-off-chrome
#+BEGIN_SRC emacs-lisp
  (dolist (mode '(tool-bar-mode scroll-bar-mode))
    (when (fboundp mode) (funcall mode -1)))
#+END_SRC

*** Startup buffers

Turn off the startup screen, and always show =*scratch*=.

#+NAME: turn-off-startup
#+BEGIN_SRC emacs-lisp
  ;; inhibit startup screen
  (setq inhibit-startup-screen t
        ;; Show *scratch* on start
        initial-buffer-choice t)
#+END_SRC

*** Font

I use [[https://github.com/tonsky/FiraCode][Fira Code]] as my default coding font:

#+BEGIN_SRC emacs-lisp
  ;; set the font
  (when (window-system)
    (set-default-font "Fira Code"))
  (if (fboundp 'mac-auto-operator-composition-mode)
      (mac-auto-operator-composition-mode))
#+END_SRC

Uncomment the last line to generate the table of ligature codes.

*** Syntax highlighting

Syntax highlighting in Emacs is called [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Font-Lock.html][font locking]]. It's enabled by
=font-lock-mode=. This turned on by default in modern Emacs systems, but it's
worth keeping around:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC

Emacs also supports multiple levels of complexity for highlighting. Setting this
value to =t= forces it to pick the maximum available (also the default):

#+BEGIN_SRC emacs-lisp
  (setq font-lock-maximum-decoration t)
#+END_SRC

*** Line and column numbers

Emacs doesn't display line numbers by the code by default. For that you want
[[http://www.emacswiki.org/emacs/LineNumbers#toc1][Linum mode]].

I want to display the current line number in the [[http://www.emacswiki.org/emacs/ModeLine][mode line]], and also the
current column number:

#+BEGIN_SRC emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+END_SRC

*** Tooltips

Emacs convention is to show help and other inline documentation in the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/message.html][message
area]]. Show help there instead of using an OS tooltip:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (tooltip-mode -1))
#+END_SRC

*** Dialogue boxes and windows

Just don't show them. Use native Emacs controls:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq use-dialog-box nil))
#+END_SRC

Make the window title display the full path of the file I'm currently editing:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b")))))
#+END_SRC

Aside: Emacs calls OS windows [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames][frames]] and divisions within frames [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][windows]]. [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Titles.html][More
information on frame titles]].

*** Cursor

I prefer a box, non-blinking cursor. So, turn off that blinking:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq-default cursor-type 'box)
    (blink-cursor-mode (- (*) (*) (*))))
#+END_SRC

Depending on the mode, let's [[http://www.emacswiki.org/emacs/ChangingCursorDynamically][change the cursor]].

#+BEGIN_SRC emacs-lisp
  (setq smf/read-only-color       "gray")
  (setq smf/read-only-cursor-type 'hbar)
  (setq smf/overwrite-color       "red")
  (setq smf/overwrite-cursor-type 'box)
  (setq smf/normal-color          "gray")
  (setq smf/normal-cursor-type    'box)

  (defun smf/set-cursor-according-to-mode ()
    "change cursor color and type according to some minor modes."

    (cond
     (buffer-read-only
      (set-cursor-color smf/read-only-color)
      (setq cursor-type smf/read-only-cursor-type))
     (overwrite-mode
      (set-cursor-color smf/overwrite-color)
      (setq cursor-type smf/overwrite-cursor-type))
     (t
      (set-cursor-color smf/normal-color)
      (setq cursor-type smf/normal-cursor-type))))

  (add-hook 'post-command-hook 'smf/set-cursor-according-to-mode)
#+END_SRC

*** Typing

Show the modifier combinations I just typed almost immediately:

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

Don't make me type =yes= or =no= to boolean interface questions:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Code commenting

A drop-in replacement for comment-dwim. If no region is selected and current
line is not blank and we are not at the end of the line, then comment current
line.

#+BEGIN_SRC emacs-lisp
  (defun comment-dwim-line (&optional arg)
    (interactive "*P")
    (comment-normalize-vars)
    (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
        (comment-or-uncomment-region (line-beginning-position) (line-end-position))
      (comment-dwim arg)))
  (global-set-key (kbd "M-;") 'comment-dwim-line)
#+END_SRC

Comment or uncomment the region or current line if no active region.

#+BEGIN_SRC emacs-lisp
  (defun comment-or-uncomment-region-or-line ()
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))
  (global-set-key (kbd "s-;") 'comment-or-uncomment-region-or-line)
#+END_SRC

*** Bells

Don't make a sound when [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Beeping.html][ringing a bell]] - flash a visual bell instead:

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Override the =ring-bell-function= to conditionally ring the bell only when it's
not a valid quit case like hitting =esc= or =C-g=. Generally this means the bell
will only ring when there's actually an error raised somehow:

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function
        (lambda ()
          "Only rings the bell if it's not a valid quit case, e.g
  keyboard-quit"
          (unless (memq this-command
                        '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
            (ding))))
#+END_SRC

*** Buffer naming

By default Emacs resolves conflicting buffer names by appending a number to
them. For instance, if I open =~/src/thing/init.el= and
=~/src/other-thing/init.el= they'll be named =init.el= and =init.el<2>=
respectively.

We can use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][Uniquify]] library to name them =thing/init.el= and
=other-thing/init.el=, which is much easier to make sense of.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

** OS X specific configuration

Besides the keyboard configuration above, there are some other specific things I
do on OS X. On OS X =system-type= is the symbol =darwin=.

*** Host name mangling

Typically OS X hosts are called things like =hostname.localconfig= or
=hostname.local=. Make Emacs report that without the extra suffix:

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq system-name (car (split-string system-name "\\."))))
#+END_SRC

*** Spelling correction

[[https://www.gnu.org/software/ispell/][ispell]] isn't generally available on OS X. [[http://aspell.net][aspell]] is available via [[https://github.com/macports/macports-ports/blob/master/textproc/aspell/Portfile][MacPorts]], so
let's use that if we can find it:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (executable-find "aspell"))
      (setq ispell-program-name (executable-find "aspell")))
#+END_SRC

On the mac, the default mouse bindings are problematic since a two-finger click
is =mouse-3= and not =mouse-2=:

#+BEGIN_SRC emacs-lisp
  (use-package flyspell :after diminish
    :ensure t
    :defer t
    :init
    (progn
      (add-hook 'prog-mode-hook 'flyspell-prog-mode)
      (add-hook 'text-mode-hook 'flyspell-mode)
      )
    :config
    ;; Sets flyspell correction to use two-finger mouse click
    (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
    (diminish 'flyspell-mode)
    )
#+END_SRC

*** dired fixes

OS X's bundled version of =ls= isn't the GNU one, so it doesn't support the
=--dired= flag. Emacs caters for that use case:

#+BEGIN_SRC emacs-lisp
  (setq dired-use-ls-dired nil)
#+END_SRC

*** sRGB display fixes

As of Emacs 24.4, [[http://lists.gnu.org/archive/html/emacs-devel/2013-12/msg00741.html][Emacs natively supports proper sRGB]] values on OS X:

#+BEGIN_SRC emacs-lisp
  (setq ns-use-srgb-colorspace t)
#+END_SRC

*** Terminal integration

Using this configuration, Emacs runs best in [[http://iterm2.com][iTerm2]].

On the desktop, Emacs integrates with the OS X clipboard, so =kill= etc. copy to
the clipboard, and =yank= copies from the clipboard.

Obviously this doesn't work in the terminal, so we need to use the
=interprogram-(cut|paste)-function= variables to copy/paste. Most of this code
gotten from [[http://mindlev.wordpress.com/2011/06/13/emacs-in-a-terminal-on-osx/#comment-20][this blog comment]].

#+BEGIN_SRC emacs-lisp
  (when (and (not (display-graphic-p)) (eq system-type 'darwin))
    (defun smf/copy-from-osx ()
      "Copies the current clipboard content using the `pbcopy` command"
      (shell-command-to-string "pbpaste"))

    (defun smf/paste-to-osx (text &optional push)
      "Copies the top of the kill ring stack to the OSX clipboard"
      (let ((process-connection-type nil))
        (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
          (process-send-string proc text)
          (process-send-eof proc))))

    (setq interprogram-cut-function 'smf/paste-to-osx)
    (setq interprogram-paste-function 'smf/copy-from-osx))
#+END_SRC

Also, allow pasting selection outside of Emacs:

#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard t)
#+END_SRC

*** Fullscreen support

On Emacs 24.4 and above, Lion-style fullscreen display is supported but I
dislike it. Define a method to toggle fullscreen pre-Lion.

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (fboundp 'toggle-frame-fullscreen))
    (defun toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      (set-frame-parameter nil 'fullscreen
                           (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

      (global-set-key (kbd "C-s-f") 'toggle-fullscreen))
#+END_SRC

On the Yosemite beta, =ns-use-native-fullscreen= is =nil=.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq ns-use-native-fullscreen nil))
#+END_SRC

Start emacs in fullscreen,

#+BEGIN_SRC emacs-lisp
  (toggle-fullscreen)
#+END_SRC

*** OS X keybindings

There are a lot of native OS X-isms that I would like to keep. Things such =⌘-a=
to select the whole buffer, or =⌘-c= to copy.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-a") 'mark-whole-buffer)
    (global-set-key (kbd "s-v") 'yank)
    (global-set-key (kbd "s-c") 'kill-ring-save)
    (global-set-key (kbd "s-x") 'kill-region)
    (global-set-key (kbd "s-s") 'save-buffer)
    (global-set-key (kbd "s-l") 'goto-line)
    (global-set-key (kbd "s-w") 'delete-window)
    (global-set-key (kbd "s-z") 'undo)
    (global-set-key (kbd "s-Z") 'undo-tree-redo)
    (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
    (global-set-key (kbd "s-k") 'kill-this-buffer)
    (global-set-key (kbd "s-r") 'recompile)
    (global-set-key (kbd "s-}") 'forward-paragraph)
    (global-set-key (kbd "s-{") 'backward-paragraph)
    (global-set-key (kbd "s-f") 'swiper)
    (global-set-key (kbd "s-g") 'isearch-repeat-forward)
    (global-set-key [(H left)]  'beginning-of-buffer)
    (global-set-key [(H right)] 'end-of-buffer)
    (global-set-key [(H down)]  [?\C-v])
    (global-set-key [(H up)]    [?\M-v]))
#+END_SRC

The =⌘-backspace= deletes text from the current position to the beginning of the
line.

#+BEGIN_SRC emacs-lisp
  (global-set-key [s-backspace] [?\C- ?\C-a backspace])
#+END_SRC

** Utility functions

*** Rename modeline

Renames the major-mode lighter in the modeline. Lifted from [[http://whattheemacsd.com/appearance.el-01.html][What the emacs.d]].

#+BEGIN_SRC emacs-lisp
  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))
#+END_SRC

*** Get keychain password

If I'm on OS X, I can fetch passwords etc. from my Keychain. This is much more
secure than storing them in configuration on disk:

#+BEGIN_SRC emacs-lisp
  (defun smf/chomp (str)
    "Chomp leading and tailing whitespace from `str'."
    (while (string-match "\\`\n+\\|^\\s-+\\|\\s-+$\\|\n+\\'" str)
      (setq str (replace-match "" t t str))) str)

  (defun smf/get-keychain-password (account-name &optional server)
    "Get `account-name' keychain password from OS X Keychain"
    (interactive "sAccount name: ")
    (smf/chomp
     (shell-command-to-string
      (concat
       "security find-"
       (if server "internet" "generic")
       "-password -wa "
       account-name
       (if server (concat " -s " server))))))
#+END_SRC

Eventually, I'd like to use auth-source instead of custom methods for accessing
the keychain, but erc is giving me problems currently.

#+BEGIN_SRC emacs-lisp
  (setq auth-sources '(macos-keychain-internet))
#+END_SRC

*** Conditionally kill Emacs

When I'm in an emacsclient, I probably just want the client to die rather than
the entire server. And, when I kill my server, I want Emacs to confirm this with
me:

#+BEGIN_SRC emacs-lisp
  (defun smf/kill-emacs ()
    "If this buffer is a client, just kill it, otherwise confirm
  the quit."
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (if (= (length (frame-list)) 1)
        (save-buffers-kill-terminal))))
#+END_SRC

Enable this, and override the default command Emacs assigns to kill itself:

#+BEGIN_SRC emacs-lisp
  (define-key (current-global-map) [remap save-buffers-kill-terminal] 'smf/kill-emacs)
#+END_SRC

Also, when using an emacsclient that is waiting, I don't want a prompt that asks
if I really want to exit. So, we define our own function and bind it to =⌘-k=.

#+BEGIN_SRC emacs-lisp
  (defun smf/kill-buffer ()
    "Murderface a buffer, don't listen to nobody, son!"
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (kill-this-buffer)))

  (add-hook 'server-switch-hook
            (lambda ()
              (local-set-key (kbd "s-k") 'smf/kill-buffer)))
#+END_SRC

*** narrow-or-widen-dwim

Taken from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][here]], this function defines a handy way to narrow the buffer. We'll
add a launcher for it bound to 'n'.

#+BEGIN_SRC emacs-lisp
  (defun smf/narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  (global-set-key (kbd "H-n") 'smf/narrow-or-widen-dwim)
#+END_SRC

*** Delete to end of buffer

In emails (and sometimes other places, too) I frequently want to delete the rest
of the buffer. We'll bind this to =C-M-d=

#+BEGIN_SRC emacs-lisp
  (defun smf/delete-to-end-of-buffer (add-to-kill-ring-p)
    "Deletes from point to end of buffer. If prefix argument is
     given, kill the region, adding it to the kill ring."
    (interactive "P")
    (if add-to-kill-ring-p
        (kill-region (point) (point-max))
      (delete-region (point) (point-max))))

  (global-set-key (kbd "C-M-d") 'smf/delete-to-end-of-buffer)
#+END_SRC

** Other modes

Emacs comes with hundreds of major and minor modes to do many, many things.
These are the ones I commonly use and have configured.

*** org

**** init

[[http://orgmode.org][org-mode]] is a plain text system for organising information and notes. We'll set
some basic settings and personal tweaks,

#+BEGIN_SRC emacs-lisp
  (use-package org :ensure t
    :defer t
    :mode ("\\.org"  . org-mode)
    :bind (;; I'll change the prefix for these function (instead of using
           ;; smf/launcher) since they are so common
           ("C-c l" . org-store-link)
           ("C-c a" . org-agenda)
           ("C-c c" . org-capture)

           :map org-mode-map
           ;; I use meta-arrow keys for navigation so let's stop org from
           ;; using them to indent
           ("<M-S-left>" . nil)
           ("<M-left>" . nil)
           ("<M-right>" . nil)
           ;; since I commonly mistype =C-c C-'= instead of =C-c '=, let's
           ;; add that keybinding,
           ("C-c C-'" . org-edit-special)

           :map org-src-mode-map
           ("C-c C-'" . org-edit-src-exit)
           ;; I find it infuriating that my muscle memory =⌘+s= in
           ;; =org-src-mode= will save the buffer as a new file. Instead,
           ;; let's make it do the same thing as =C-c '=
           ("s-s" . org-edit-src-exit))
    :config
    ;; don't auto-fold my documents:
    (setq org-startup-folded nil

          ;; automatically apply syntax highlighting:
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          org-ellipsis "⤵"

          ;; and don't prompt
          org-confirm-babel-evaluate nil

          ;; when using imenu, make sure I can follow the outline to the full available
          ;; depth
          org-imenu-depth 6

          ;; also, I like using shift+arrow keys to highlight, so let's set that
          org-support-shift-select 'always

          ;; set up MobileOrg (which is sweet!)
          org-directory "~/Dropbox/org"

          ;; also, set the file for capturing todos
          smf/org-input "~/Dropbox/org/organizer.org"

          org-default-notes-file smf/org-input

          ;; set to the name of the file where new notes will be stored
          org-mobile-inbox-for-pull smf/org-input

          org-mobile-directory "~/Dropbox/Apps/MobileOrg"

          ;; now, set the agenda files,
          org-agenda-files (list "~/Dropbox/org/organizer.org"
                                 "~/Dropbox/org/bitbucket.org"
                                 "~/Dropbox/org/phd.org"
                                 "~/Dropbox/org/hg.org"
                                 "~/Dropbox/org/personal.org")

          ;; please don't close and mess up my windows,
          org-agenda-window-setup 'current-window
          org-agenda-restore-windows-after-quit 't

          ;; add a nice, little template to use along with some shortcuts
          org-capture-templates
          `(("t" "Tasks" entry
             (file+headline "~/Dropbox/org/organizer.org" "Inbox")
             "* TODO %?\nCaptured %<%Y-%m-%d %H:%M>\n%a\n\n%i" "Basic task2 data")
            ("i" "Interrupting task" entry
             (file+headline "~/Dropbox/org/organizer.org" "Inbox")
             "* STARTED %^{Task}"
             :clock-in :clock-resume))

          org-todo-keywords '((sequence "TODO(t)" "|" "DONE(d)")))

    ;; shortcut to launch file for refiling
    (smf/add-launcher "o" (lambda ()
                            (interactive)
                            (find-file smf/org-input)))

    ;; also, let's turn on auto-fill-mode
    (add-hook 'org-mode-hook 'auto-fill-mode))
#+END_SRC

**** org-journal

A great plugin for =org-mode= is =org-journal= to take daily and weekly notes.
I was inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html#org5b9f9d2][Sacha Chau's setup]] (and her [[http://sachachua.com][great website]]) to also revamp my
workflow to use =org-mode= even more better.

So, we'll start with some basic settings,

#+BEGIN_SRC emacs-lisp
  (use-package org-journal
    :after org
    :ensure t
    :defer t
    :config
    (setq org-log-done t
          org-agenda-persistent-filter t
          org-agenda-sticky t
          org-enforce-todo-dependencies t
          org-cycle-separator-lines 0
          org-blank-before-new-entry (quote ((heading)
                                             (plain-list-item . auto)))

          org-use-fast-todo-selection t
          org-log-into-drawer t
          org-log-state-notes-insert-after-drawers nil
          org-fast-tag-selection-single-key nil
          org-return-follows-link t
          org-confirm-babel-evaluate nil

          org-refile-targets '((org-agenda-files . (:maxlevel . 6)))))
#+END_SRC

The org-protocol plugin is sweet awesomeness. It allows native apps to send
capture notes to Emacs,

#+BEGIN_SRC emacs-lisp
  (use-package org-protocol
    :after org)
#+END_SRC

**** misc org

Let's use pomodoro!

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :after org
    :ensure t
    :defer t
    :config
    (setq org-pomodoro-play-sounds nil))
#+END_SRC

While we're at it, let's add notmuch and twitter bootstrap integration,

#+BEGIN_SRC emacs-lisp
  (use-package org-notmuch
    :after notmuch
    :defer t)
  (use-package ox-twbs
    :after org
    :defer
    :ensure t)
#+END_SRC

*** ido

[[http://www.emacswiki.org/emacs/InteractivelyDoThings][ido]] is a mode for narrowing candidates as you type. It has excellent
integration with buffer switching and finding files. [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mastering Emacs has a good
guide to Ido]].

First we enable =ido-mode= globally and enable =ido-everywhere=, which enables
Ido for buffer and file reading. Also, we force Ido to [[http://stackoverflow.com/a/11341239/61435][ignore Dropbox cruft]],

#+BEGIN_SRC emacs-lisp
  (use-package ido
    :ensure t
    :config
    (add-to-list 'ido-ignore-files "Icon\n")

    ;; also ignore certain extensions that I don't care about
    (setq completion-ignored-extensions
          '(".o" ".elc" "~" ".bin" ".bak" ".obj" ".map" ".a" ".ln" ".mod" ".gz"
            ".aux" ".tdo" ".fmt" ".swp" ".pdfsync" ".pdf" ".vrb" ".idx" ".ind"
            ".bbl" ".toc" ".blg" ".snm" ".ilg" ".log" ".out" ".pyc" ".DS_Store"
            "-blx.bib" ".run.xml" ".hi" ".fls" ".fdb_latexmk" ".bcf" ".rel")

          ;; Speed up ido by using less candidates
          ido-max-prospects 10

          ;; Match arbitrary points in strings
          ido-enable-prefix nil

          ;; Match across entire string
          ido-enable-flex-matching t

          ;; Create a new buffer if there's no match candidate
          ido-create-new-buffer 'always

          ;; Don't try and guess if the string under point is a file
          ido-use-filename-at-point nil

          ;; case-insensitive matching
          ido-case-fold t

          ;; don't store old files as virtual buffers
          ido-use-virtual-buffers nil

          ;; store ido temporary directory cache elsewhere:
          ido-save-directory-list-file (expand-file-name ".ido.last" smf/tmp-local-dir))

    (ido-mode t)
    (ido-everywhere t))
#+END_SRC

*** bookmarks

Emacs has robust [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Bookmarks.html][bookmarking functionality]]. It uses a file to persit the list of
bookmarks, so make sure that file is in my custom temporary directory:

#+BEGIN_SRC emacs-lisp
  (use-package bookmark
    :config
    (setq bookmark-default-file
          (expand-file-name ".emacs.bmk" smf/tmp-local-dir)))
#+END_SRC

*** eldoc-mode

[[http://www.emacswiki.org/emacs/ElDoc][eldoc-mode]] is a minor mode that displays context-sensitive help when editing
Emacs lisp (eg information about arity of functions). Enable that for
=emacs-lisp-mode=:

#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :bind (:map emacs-lisp-mode-map
                ("C-c C-b" . eval-buffer))
    :config
    (add-hook 'emacs-lisp-mode-hook #'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook #'turn-on-eldoc-mode)
    (add-hook 'prog-mode-hook #'turn-on-eldoc-mode))
#+END_SRC

*** python-mode

As of 24.2, Emacs ships with a [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs#toc1][robust Python mode]]. However, when navigating
=SnakeCase= words (eg class names), =forward-word= etc don't work correctly.

We can work around that using [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html#Subword-Movement][subword-mode]]:

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode)
    :config
    (add-hook 'python-mode-hook #'subword-mode))
#+END_SRC

*** ruby-mode

As of 24.4, Emacs comes with a much better [[http://www.masteringemacs.org/articles/2013/12/29/whats-new-in-emacs-24-4/][Ruby mode]]. However it doesn't come
with =subword-mode= enabled by default:

#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :mode "\\.rb\\'"
    :interpreter "ruby"
    :config
    (add-hook 'ruby-mode-hook #'subword-mode))
#+END_SRC

*** tramp mode

=tramp-mode= is a package that provides [[https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top][remote file editing]], eg =find-file
/user@host:file=. This allows one to edit files on other servers using your
local Emacs (rather than the Vim user's equivalent of editing the file on the
server).

All of the below are wrapped in an =after-load= construct because =tramp-mode=
isn't loaded by default on older versions of Emacs.

First we set the default mode to be =ssh= (it's normally =scp=). There are two
reasons for this choice:

- =ssh= takes a port number as an argument, whereas =scp= doesn't
- It's [[http://www.gnu.org/software/tramp/#Default-Method][apparently faster]] for smaller files

We also want to alter the list of allowed proxies (tramp uses a whitelist for
patterns that it can remotely access) so I can edit remote files as sudo, eg
=find-file /sudo:example.com/etc/something-owned-by-root=.

I got this code from the [[http://www.gnu.org/software/tramp/#Multi_002dhops][Multi-hops section of the tramp manual]].

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :config
    (add-to-list 'tramp-default-proxies-alist
                 '(nil "\\`root\\'" "/ssh:%h:"))

    ;; also make sure we can edit local files as sudo - this is normally
    ;; disallowed for security reasons
    (add-to-list 'tramp-default-proxies-alist
                 '((regexp-quote (system-name)) nil nil))

    (setq tramp-default-method "ssh"
          tramp-ssh-controlmaster-options (concat "-o ControlPath=/tmp/tramp.%%r@%%h:%%p "
                                                  "-o ControlMaster=auto "
                                                  "-o ControlPersist=no")))
#+END_SRC

More on the last two incantations at [[http://emacs-fu.blogspot.co.uk/2009/10/editing-files-owned-by-root.html][emacs-fu's guide to editing files owned by root]].

*** recentf

[[http://www.emacswiki.org/emacs/RecentFiles][recentf]] stores a list of recently opened files. The list of files contains any
files Emacs has read, not just files I've explicitly opened. Clean that list to
exclude Emacs metafiles, package cruft etc.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    ;; never clean up the list:
    (setq recentf-auto-cleanup 'never
          recentf-max-saved-items 500
          recentf-max-menu-items 15

          ;; customize the place =recentf= persists its list of items:
          recentf-save-file (expand-file-name ".recentf"
                                              smf/tmp-local-dir))

    ;; strip =$HOME= from the front of =recentf= candidate files
    (add-to-list 'recentf-filename-handlers 'abbreviate-file-name)

    (add-to-list 'recentf-exclude "[/\\]\\.elpa/")
    (add-to-list 'recentf-exclude "[/\\]\\.ido\\.last\\'" )
    (add-to-list 'recentf-exclude "[/\\]\\.git/")
    (add-to-list 'recentf-exclude ".*\\.gz\\'")
    (add-to-list 'recentf-exclude ".*-autoloads\\.el\\'")
    (add-to-list 'recentf-exclude "[/\\]archive-contents\\'")
    (add-to-list 'recentf-exclude "[/\\]\\.loaddefs\\.el\\'")
    (add-to-list 'recentf-exclude "url/cookies")
    (add-to-list 'recentf-exclude ".*\\emacs.bmk\\'")
    (add-to-list 'recentf-exclude "README\\.el\\'")
    (add-to-list 'recentf-exclude "/custom\\.el\\'")

    (recentf-mode))
#+END_SRC

*** ediff

[[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][ediff]] is a full-featured visual diff and merge tool, built into Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :commands hg-mergetool-emacsclient-ediff
    :config
    ;; Make sure that the window split is always side-by-side:
    (setq ediff-split-window-function 'split-window-horizontally

          ;; ignore whitespace changes
          ediff-diff-options "-w"

          ;; only ever use one set of windows in one frame
          ediff-window-setup-function 'ediff-setup-windows-plain

          ;; don't keep ediff file instances around
          ediff-keep-variants nil

          ;; finally, we add customizations for using ediff with mercurial
          hg-mergetool-emacsclient-ediff-active nil)

    (defvar ediff-after-quit-hooks nil
      "* Hooks to run after ediff or emerge is quit.")

    (defadvice ediff-quit (after edit-after-quit-hooks activate)
      (run-hooks 'ediff-after-quit-hooks))


    (defun local-ediff-before-setup-hook ()
      (setq local-ediff-saved-frame-configuration (current-frame-configuration))
      (setq local-ediff-saved-window-configuration (current-window-configuration))
      (global-auto-revert-mode 0)
      ;; (local-ediff-frame-maximize)
      (if hg-mergetool-emacsclient-ediff-active
          (raise-frame)))

    (defun local-ediff-quit-hook ()
      (set-frame-configuration local-ediff-saved-frame-configuration)
      (set-window-configuration local-ediff-saved-window-configuration))

    (defun local-ediff-suspend-hook ()
      (set-frame-configuration local-ediff-saved-frame-configuration)
      (set-window-configuration local-ediff-saved-window-configuration))

    (add-hook 'ediff-before-setup-hook 'local-ediff-before-setup-hook)
    (add-hook 'ediff-quit-hook 'local-ediff-quit-hook 'append)
    (add-hook 'ediff-suspend-hook 'local-ediff-suspend-hook 'append)

    ;; Useful for ediff merge from emacsclient.
    (defun hg-mergetool-emacsclient-ediff (local remote base merged)
      (setq hg-mergetool-emacsclient-ediff-active t)
      (if (file-readable-p base)
          (ediff-merge-files-with-ancestor local remote base nil merged)
        (ediff-merge-files local remote nil merged))
      (recursive-edit))

    (defun hg-mergetool-emacsclient-ediff-after-quit-hook ()
      (global-auto-revert-mode t)
      (exit-recursive-edit))

    (add-hook 'ediff-after-quit-hooks 'hg-mergetool-emacsclient-ediff-after-quit-hook 'append))
#+END_SRC

*** Persistent =*scratch*= buffer

Stolen from [[https://github.com/jwiegley/dot-emacs/blob/master/lisp/persistent-scratch.el][jwiegley's persistent-scratch]]:

Emacs has a handy, but sometimes decried, feature called the "scratch" buffer.
This is a special buffer which is created upon startup and allows the user to
type in and evaluate Emacs Lisp code. Handy for editing tasks too specific (or
not useful enough) to put into an function and handy for exploratory Emacs Lisp
interactive development (although this development is just as easily
accomplished in any file in Lisp mode).

One problem with =*scratch*= is that its tempting to put significant bits of
code (and other information) into it. This isn't a problem in itself, but
=*scratch*= isn't associated with a file, and its contents are lost without
warning when Emacs is closed. Today we'll modify the default behavior of Emacs
so that it saves the scratch buffer to a file on exit and loads it back in on
startup.

#+BEGIN_SRC emacs-lisp
  (defcustom smf/persistent-scratch-file-name "~/.emacs.d/persistent-scratch"
    "Location of *scratch* file contents for persistent-scratch.")

  (defun smf/save-persistent-scratch ()
    "Write the contents of *scratch* to the file name
    `persistent-scratch-file-name'."
    (with-current-buffer (get-buffer-create "*scratch*")
      (write-region (point-min) (point-max) smf/persistent-scratch-file-name)))

  (defun smf/load-persistent-scratch ()
    "Load the contents of `persistent-scratch-file-name' into the
    scratch buffer, clearing its contents first."
    (if (file-exists-p smf/persistent-scratch-file-name)
        (with-current-buffer (get-buffer "*scratch*")
          (delete-region (point-min) (point-max))
          (insert-file-contents smf/persistent-scratch-file-name))))

  (push #'smf/load-persistent-scratch after-init-hook)
  (push #'smf/save-persistent-scratch kill-emacs-hook)

  (run-with-idle-timer 300 t 'smf/save-persistent-scratch)
#+END_SRC

*** Known config files

I have a few files in my dotfiles repo that are known to be shell files, so
let's add them:

#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '(".?aliases" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?bash_prompt" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?bashrc" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?exports" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?functions" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?osx" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?osx" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?profile" . sh-mode) auto-mode-alist))
#+END_SRC

Same with conf-mode,

#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '(".?hgrc" . conf-mode) auto-mode-alist))
#+END_SRC

*** whitespace-mode

I like whitespace-mode for programming and text modes (including org),

#+BEGIN_SRC emacs-lisp
  (require 'whitespace)
  (global-whitespace-mode t)
  (setq whitespace-global-modes '(text-mode prog-mode org-mode))
#+END_SRC

But most of the time, I only want to see tabs and trailing spaces,

#+BEGIN_SRC emacs-lisp
  (setq whitespace-style '(trailing face tabs tab-mark lines-tail))
  (setq whitespace-display-mappings '((space-mark 32 [183] [46])
                                      (newline-mark 10 [182 10])
                                      (tab-mark 9 [9655 9] [92 9])))
#+END_SRC

*** Highlight C functions

Taken from [[http://stackoverflow.com/questions/14715181/emacs-function-call-highlight][this StackOverflow]] question, we use it to highlight functions in C,

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'c-mode
   '(("\\<\\(\\sw+\\) ?(" 1 'font-lock-function-name-face)))
#+END_SRC

** Third-party packages

Emacs has a built-in [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging][package manager]].

Rather than using Git submodules or similar my Emacs configuration is set up to
automatically download and install any required packages at load time. This
makes my configuration fully portable.

First set up convenience function (borrowed from [[https://github.com/purcell/emacs.d/blob/aa789c9745b13612c4fea6e638d81d8ebbfecdf8/init-elpa.el#L63-L73][Steve Purcell's emacs config]])
that installs a package if it's not already installed. [[file:init.el::(defun%20require-package%20(package%20&optional%20min-version%20no-refresh][See init.el for code]].

*** Configure package manager

**** Custom package install location

The default value for =package-user-dir= is =~/.emacs.d/elpa= - since these are
third-party packages that are dynamically installed I'd prefer them to be in a
[[http://en.wikipedia.org/wiki/Dot-file][hidden directory]].

Packages are also [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][byte compiled]] upon installation, so namespace the install
directory to the version of Emacs I'm using.

Final result should be something like =~/.emacs.d/.elpa/24.3.93.1/=.

[[file:init.el::(setq%20package-user-dir][see init.el for code]].

**** Customise package repositories to install from

By default Emacs only installs files from [[http://www.gnu.org/software/emacs/manual/html_node/efaq/Packages-that-do-not-come-with-Emacs.html#Packages-that-do-not-come-with-Emacs][ELPA]]. Some of these packages are old
or out of date, and they don't track GitHub repositories.

I want to also add:

- [[https://github.com/milkypostman/melpa#melpa][MELPA]] (tracks GitHub repositories, is much more comprehensive)

[[file:init.el::(setq%20package-archives][see init.el for code]].

*** diminish

[[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] removes or abbreviates the minor mode indicators that can clutter up
one's modeline.

#+BEGIN_SRC emacs-lisp
  (require-package 'diminish)
#+END_SRC

Diminish =subword-mode=, =eldoc-mode=, and =auto-revert-mode=:

#+BEGIN_SRC emacs-lisp
  (after-load 'diminish
    (after-load 'subword
      (diminish 'subword-mode))
    (after-load 'eldoc
      (diminish 'eldoc-mode))
    (after-load 'autorevert
      (diminish 'auto-revert-mode)))
#+END_SRC

Also, diminish some built-in modes:

#+BEGIN_SRC emacs-lisp
  (after-load 'diminish
    (diminish 'overwrite-mode)
    (diminish 'global-whitespace-mode)
    (diminish 'auto-fill-function))
#+END_SRC

*** paradox

[[https://github.com/Bruce-Connor/paradox][paradox]] is an advanced package.el frontend with GitHub integration.

#+BEGIN_SRC emacs-lisp
  (require-package 'paradox)
#+END_SRC

Automatically 'star' packages on GitHub after I install them (so I can easily
follow changes to them):

#+BEGIN_SRC emacs-lisp
  (setq paradox-automatically-star t)
#+END_SRC

Add launch command:

#+BEGIN_SRC emacs-lisp
  (smf/add-launcher "p" 'paradox-list-packages)
#+END_SRC

**** async mode

Paradox now [[https://github.com/Bruce-Connor/paradox/commit/e341a900609974802ad92d5bb43083fcf83ef432#diff-2d43bf4d9c7b9686d0895974900dfd05R18][supports an asynchronous mode]] which requires the =async= package:

#+BEGIN_SRC emacs-lisp
  (require-package 'async)
  (setq paradox-execute-asynchronously t)
#+END_SRC

*** exec-path-from-shell

OS X doesn't use the environment variables available in a shell in a GUI
environment ([[https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/EnvironmentVars.html][more here]]).

Since Emacs runs shell commands regularly it's important that the same =PATH= is
available to my editor as [[https://www.macports.org][MacPorts]] etc. set and use.

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] is a package that copies across =PATH= and other variables
to the Emacs environment.

I only want this to be installed and enabled on OS X.

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (require-package 'exec-path-from-shell)
    (setq exec-path-from-shell-variables '("PATH"  "MANPATH" "SHELL"))
    (exec-path-from-shell-initialize))
#+END_SRC

*** smex

[[https://github.com/nonsequitur/smex][smex]] is an advanced completion mode for =execute-extended-command= (usually
known as =M-x=).

#+BEGIN_SRC emacs-lisp
  (require-package 'smex)
#+END_SRC

Replace =execute-extended-command='s keyboard shortcuts:

#+BEGIN_SRC emacs-lisp
  (define-key (current-global-map) [remap execute-extended-command] 'smex)
#+END_SRC

Make sure we stop the annoying "click this menubar" advice in the buffer:

#+BEGIN_SRC emacs-lisp
  (setq-default smex-key-advice-ignore-menu-bar t)
#+END_SRC

Move =smex='s cache file out of the home directory:

#+BEGIN_SRC emacs-lisp
  (setq smex-save-file (expand-file-name ".smex-items" smf/tmp-local-dir))
#+END_SRC

*** ido-ubiquitous

[[https://github.com/DarwinAwardWinner/ido-ubiquitous][ido-ubiquitous]] mode enables ido in many more places than the default ido setup:

#+BEGIN_SRC emacs-lisp
  (require-package 'ido-ubiquitous)
  (ido-ubiquitous-mode 1)
#+END_SRC

Unicode lists are much, much larger than the default max of 30,000 so we set to
5,000,000.

#+BEGIN_SRC emacs-lisp
  (setq ido-ubiquitous-max-items 5000000)
#+END_SRC

Also, let's add bringing up a unicode list to our launcher.

#+BEGIN_SRC emacs-lisp
  (smf/add-launcher "U" 'insert-char)
#+END_SRC

*** ido-vertical

[[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertical]] mode renders the ido prompt vertically instead of horizontally. I
find this easier to read.

#+BEGIN_SRC emacs-lisp
  (require-package 'ido-vertical-mode)
  (ido-vertical-mode) ;; autoloaded
  (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
#+END_SRC

Because it's displayed vertically and I want to save screen real estate, I want
to reduce the maximum number of candidates ido displays:

#+BEGIN_SRC emacs-lisp
  (setq ido-max-prospects 5)
#+END_SRC

*** flx-ido

[[https://github.com/lewang/flx][flx-ido]] is an advanced flex-matching algorithm that's significantly faster and
more accurate than the built-in method.

#+BEGIN_SRC emacs-lisp
  (require-package 'flx-ido)
#+END_SRC

The =flx-ido= documentation suggests upping the threshold at which GC occurs
within Emacs so that =flx= can cache its candidate lists for longer (it's
already set in init.el for early processing):

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 200000000)
#+END_SRC

Finally we cause =flx-ido-mode= to take over ido:

#+BEGIN_SRC emacs-lisp
  (flx-ido-mode 1)
#+END_SRC

*** swiper / ivy

Ivy - a generic completion frontend for Emacs, Swiper - isearch with an
overview, and more. [[http://oremacs.com/swiper][Oh, man!]]

#+BEGIN_SRC emacs-lisp
  (require-package 'counsel)
  (ivy-mode)
  (after-load 'diminish
    (diminish 'ivy-mode))
#+END_SRC

Useful setting that adds =recentf= and =bookmarks= to =ivy-switch-buffer=

#+BEGIN_SRC emacs-lisp
  (setq ivy-use-virtual-buffers t)
#+END_SRC

Ivy-based interface to standard commands

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s") 'swiper)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
#+END_SRC

=ivy-resume= resumes the last Ivy-based completion.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-r") 'ivy-resume)
#+END_SRC

Let's use ivy for some common projects

#+BEGIN_SRC emacs-lisp
  (setq magit-completing-read-function 'ivy-completing-read)
  (setq projectile-completion-system 'ivy)
#+END_SRC

Fuzzy matching

#+BEGIN_SRC emacs-lisp
  (require-package 'flx)
  (setq ivy-initial-inputs-alist nil)     ; don't insert '^' into regex
  (setq ivy-re-builders-alist
        '((t . ivy--regex-plus)))
  ;; (setq ivy-re-builders-alist
  ;;       '((t . ivy--regex-fuzzy)))
#+END_SRC

**** ivy-view

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c v") 'ivy-push-view)
  (global-set-key (kbd "C-c V") 'ivy-pop-view)
#+END_SRC

*** avy

I'm choosing =avy= over =ace-jump-mode= for tighter integration with
=ivy-mode=.

[[https://github.com/abo-abo/avy][avy]] allows one to jump around the buffer to named characters (it's easier to
watch the video on that link than explain).

#+BEGIN_SRC emacs-lisp
  (require-package 'avy)
  (global-set-key (kbd "H-;") 'avy-goto-char)
  (global-set-key (kbd "H-<return>") 'avy-goto-line)
  (global-set-key (kbd "H-'") 'avy-goto-word-1)
#+END_SRC

*** popwin

[[https://github.com/m2ym/popwin-el][popwin]] is a popup window manager that helps make the behaviour of compilation
buffers, search buffers etc. a bit more sane.

#+BEGIN_SRC emacs-lisp
  (require-package 'popwin)
#+END_SRC

As well as the defaults, I want [[ag]], [[flycheck]] and [[http://www.emacswiki.org/emacs/OccurMode][occur]] to 'pop'. I don't want to
auto-select the =Compile-Log= process buffer as it's for information only.

#+BEGIN_SRC emacs-lisp
  (after-load 'popwin
    (add-to-list 'popwin:special-display-config `"*ag search*")
    (add-to-list 'popwin:special-display-config `"*Flycheck errors*")
    (add-to-list 'popwin:special-display-config `"*Occur*")
    (add-to-list 'popwin:special-display-config `("*Compile-Log*" :noselect t)))
#+END_SRC

Load [[popwin]] and configure keyboard shortcuts:

#+BEGIN_SRC emacs-lisp
  (require 'popwin)
  (popwin-mode 1)
  (global-set-key (kbd "C-c P") 'popwin:popup-last-buffer)
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-P") 'popwin:popup-last-buffer))
#+END_SRC

*** goto-chg

Goto last change in current buffer.

#+BEGIN_SRC emacs-lisp
  (require-package 'goto-chg)
  (global-set-key (kbd "H-.") 'goto-last-change)
#+END_SRC

*** ripgrep

[[https://github.com/nlamirault/ripgrep.el][ripgrep]] is an Emacs frontend to [[https://github.com/BurntSushi/ripgrep][the rg command]], a grep-like code-searching tool. It's
installed via cargo on my Mac.

#+BEGIN_SRC emacs-lisp
  (require-package 'ripgrep)
;;  (require 'projectile-ripgrep)
#+END_SRC

Set up some key bindings:

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (global-set-key (kbd "H-f") 'projectile-ripgrep))
#+END_SRC

*** projectile

[[https://github.com/bbatsov/projectile][projectile]] is a minor mode for performing commands over a single 'project' or
grouping of files.

#+BEGIN_SRC emacs-lisp
  (require-package 'projectile)
  (projectile-global-mode)
#+END_SRC

I want my keyboard shortcuts to be the same in Projectile as in non-Projectile
buffers, so do some remapping:

#+BEGIN_SRC emacs-lisp
  (after-load 'projectile
    (define-key projectile-mode-map [remap ag-project] 'projectile-ag))
#+END_SRC

Since I use =ag=, always use that instead of =grep=:

#+BEGIN_SRC emacs-lisp
  (after-load 'projectile
    (define-key projectile-mode-map [remap projectile-grep] 'projectile-ag))
#+END_SRC

Also define a convenience keyboard shortcut to switch between buffers from the same project:

#+BEGIN_SRC emacs-lisp
  (after-load 'projectile
    (global-set-key (kbd "s-b") 'projectile-switch-to-buffer)
    (global-set-key (kbd "C-x 4 s-b") 'projectile-switch-to-buffer-other-window)
    (smf/add-launcher "s" 'projectile-switch-project))
#+END_SRC

Some compiler output has ansi color, so let's escape that,

#+BEGIN_SRC emacs-lisp
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region (point-min) (point-max))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

As usual, diminish an always-on mode,

#+BEGIN_SRC emacs-lisp
  (after-load 'projectile
    (diminish 'projectile-mode))
#+END_SRC

Let's use caching,

#+BEGIN_SRC emacs-lisp
  (after-load 'projectile
    (setq projectile-enable-caching t))
#+END_SRC

*** undo-tree

[[http://www.dr-qubit.org/undo-tree/undo-tree.el][undo-tree-mode]], a mode which allows one to visualise their undo/redo history:

#+BEGIN_SRC emacs-lisp
  (require-package 'undo-tree)
  (global-undo-tree-mode 1)
#+END_SRC

Also, diminish this mode:

#+BEGIN_SRC emacs-lisp
  (after-load 'undo-tree
    (diminish 'undo-tree-mode))
#+END_SRC

*** smartparens

[[https://github.com/Fuco1/smartparens][smartparens]] is a [[paredit]] like minor-mode for many more things than just Lisp.

=show-smartparens-mode= is a replacement mode for =show-paren-mode=.

#+BEGIN_SRC emacs-lisp
  (require-package 'smartparens)
  (require 'smartparens-config)
  (after-load 'smartparens
    (require 'smartparens-config)
    (add-hook 'prog-mode-hook #'smartparens-mode))
#+END_SRC

*** gtags

Experiment with gtags.

#+BEGIN_SRC emacs-lisp
  (require-package 'ggtags)
#+END_SRC

I already have the project name from [[projectile]] so let's remove the ggtags
project name,

#+BEGIN_SRC emacs-lisp
  (setq ggtags-mode-line-project-name nil)
#+END_SRC

Also, diminish this mode:

#+BEGIN_SRC emacs-lisp
  (after-load 'ggtags
    (after-load 'diminish
      (diminish 'ggtags-mode)))
#+END_SRC

And, finally, load it for c-like modes,

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                (ggtags-mode 1))))
#+END_SRC

*** company

[[https://github.com/company-mode/company-mode][company-mode]] is a modern and modular completion framework (the other one Emacs
people use is [[http://www.emacswiki.org/emacs/AutoComplete][autocomplete]]. I chose =company= because it's well-maintained and
has better code for integrating with).

**** configuration

Make the lighter shorter:

#+BEGIN_SRC emacs-lisp
  (after-load 'company
    (after-load 'diminish
      (diminish 'company-mode "com")))
#+END_SRC

**** enable company mode in programming buffers only

Define a function to enable company-mode and overwrite [[hippie]]'s key binding for
the local buffer only (this means I can use the same key binding for completion
no matter which minor mode I'm using):

#+BEGIN_SRC emacs-lisp
  (defun smf/enable-company-mode ()
    "Enables company-mode and overloads hippie-expand's binding"
    (company-mode 1)
    (diminish 'company-mode)
    (global-set-key (kbd "TAB") #'company-indent-or-complete-common)
    (setq company-tooltip-align-annotations t)
    (define-key (current-local-map) [remap dabbrev-expand] 'company-complete))
#+END_SRC

Add this function to any modes derived from =prog-mode=:

#+BEGIN_SRC emacs-lisp
  (after-load 'company
    (add-hook 'prog-mode-hook 'smf/enable-company-mode))
#+END_SRC

**** Install and load company

#+BEGIN_SRC emacs-lisp
  (require-package 'company)
  (require 'company)
#+END_SRC

**** Enable flx matching

#+BEGIN_SRC emacs-lisp
  (require-package 'company-flx)
  (after-load 'company
    (company-flx-mode))
#+END_SRC

*** Math symbols

Insert unicode math symbols based on the LaTeX command,

#+BEGIN_SRC emacs-lisp
  (after-load 'company
    (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

*** Xcode

Remove this since it seems to be defunct

#+BEGIN_SRC emacs-lisp
  (after-load 'company
    (setq company-backends (remove 'company-xcode company-backends)))
#+END_SRC

**** Emoji

#+BEGIN_SRC emacs-lisp
  (require-package 'company-emoji)
  (after-load 'company
    (add-to-list 'company-backends 'company-emoji))
#+END_SRC

**** Quickhelp

#+BEGIN_SRC emacs-lisp
  (require-package 'company-quickhelp)
  (company-quickhelp-mode t)
#+END_SRC

*** flycheck

[[https://github.com/flycheck/flycheck][flycheck]] is a modern, more easily customisable version of [[http://www.emacswiki.org/emacs/FlyMake][flymake]]. It's used to
perform on-the-fly syntax checking and linting.

#+BEGIN_SRC emacs-lisp
  (require-package 'flycheck)
  (require 'flycheck)
  (after-load 'flycheck
    (setq
     ;; don't show anything in the left fringe
     flycheck-indication-mode nil)
    (add-hook 'python-mode-hook 'flycheck-mode)
    (diminish 'flycheck-mode))
#+END_SRC

Also, we add some keymaps,

#+BEGIN_SRC emacs-lisp
  (after-load 'flycheck
    (define-key flycheck-mode-map (kbd "H->") 'flycheck-next-error)
    (define-key flycheck-mode-map (kbd "H-<") 'flycheck-previous-error))
#+END_SRC

*** puppet-mode

[[https://github.com/lunaryorn/puppet-mode][puppet-mode]] is a major mode for editing =.pp= files.

#+BEGIN_SRC emacs-lisp
  (require-package 'puppet-mode)
#+END_SRC

*** markdown-mode

[[http://melpa.milkbox.net/#/markdown-mode][markdown-mode]] is a major mode for editing Markdown files.

#+BEGIN_SRC emacs-lisp
  (require-package 'markdown-mode)
#+END_SRC

There's no official Markdown file extension, so support all the unofficial ones:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.ft$" . markdown-mode)) ;; FoldingText
#+END_SRC

Rebind common keys,

#+BEGIN_SRC emacs-lisp
  (after-load 'markdown-mode
    (define-key markdown-mode-map (kbd "<M-left>") nil)
    (define-key markdown-mode-map (kbd "<M-right>") nil))
#+END_SRC

*** markdown-preview-mode

#+BEGIN_SRC emacs-lisp
  (require-package 'markdown-preview-mode)
  (after-load 'markdown-preview-mode
    (define-key markdown-mode-map (kbd "<M-left>") nil)
    (define-key markdown-mode-map (kbd "<M-right>") nil))

  (setq markdown-command "multimarkdown")
#+END_SRC

*** web-mode

[[https://github.com/fxbois/web-mode][web-mode]] is a major mode for editing templates and HTML. It supports a very
broad range of template languages and is highly configurable.

#+BEGIN_SRC emacs-lisp
  (require-package 'web-mode)
#+END_SRC

[[http://jinja.pocoo.org/docs/][Jinja]] templates are mostly like [[https://docs.djangoproject.com/en/dev/topics/templates/][Django templates]], so just force them to behave
like that:

#+BEGIN_SRC emacs-lisp
  (after-load 'web-mode
    (setq web-mode-engines-alist
          '(("\\.jinja\\'" . "django"))))
#+END_SRC

Enable [[web-mode]] by default for several common file extensions:

#+BEGIN_SRC emacs-lisp
  (dolist (alist '(("\\.html$'" . web-mode)
                   ("\\.html\\.erb$" . web-mode)
                   ("\\.mustache$" . web-mode)
                   ("\\.jinja$" . web-mode)
                   ("\\.php$" . web-mode)))
    (add-to-list 'auto-mode-alist alist))
#+END_SRC

*** idomenu

[[http://melpa.milkbox.net/#/idomenu][idomenu]] offers [[ido]] completion over [[http://www.emacswiki.org/emacs/ImenuMode][imenu]] candidates. It allows me to navigate
through classes etc. using completion for methods.

#+BEGIN_SRC emacs-lisp
  (require-package 'idomenu)
#+END_SRC

Add it to my launcher:

#+BEGIN_SRC emacs-lisp
  (smf/add-launcher "i" 'idomenu)
#+END_SRC

Automatically rescan the current file so =imenu= is up to date:

#+BEGIN_SRC emacs-lisp
  (setq imenu-auto-rescan t)
#+END_SRC

*** yaml-mode

Regrettably I need to occasionally edit [[http://www.yaml.org][YAML]].

#+BEGIN_SRC emacs-lisp
  (require-package 'yaml-mode)
#+END_SRC

*** Whole line or region

It's very convenient to select the whole line when no region is active.

#+BEGIN_SRC emacs-lisp
  (require-package 'whole-line-or-region)
  (whole-line-or-region-mode)
#+END_SRC

Also, diminish this mode:

#+BEGIN_SRC emacs-lisp
  (after-load 'diminish
    (diminish 'whole-line-or-region-mode))
#+END_SRC

*** crosshairs

Highlights both the line and the column.

#+BEGIN_SRC emacs-lisp
  (require-package 'crosshairs)
#+END_SRC

Always enable this mode and bind =C-|= to highlight the column

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
  (global-hl-line-highlight)
  (global-set-key (kbd "C-|") 'column-highlight-mode)
#+END_SRC

*** highlight-thing

Global minor mode to highlight thing under point.

#+BEGIN_SRC emacs-lisp
  (require-package 'highlight-thing)
  (global-set-key (kbd "H-h") 'highlight-thing-mode)
  (after-load 'diminish
    (diminish 'highlight-thing-mode))
#+END_SRC

*** violatile highlights

Minor mode for visual feedback on some operations in Emacs.

#+BEGIN_SRC emacs-lisp
  (require-package 'volatile-highlights)
  (volatile-highlights-mode t)
  (after-load 'diminish
    (diminish 'volatile-highlights-mode))
#+END_SRC

*** drag-stuff

Drag stuff around in Emacs with convenient keybindings.

#+BEGIN_SRC emacs-lisp
  (require-package 'drag-stuff)
  (setq drag-stuff-modifier '(meta control))
  (drag-stuff-global-mode 1)
  (after-load 'diminish
    (diminish 'drag-stuff-mode))
#+END_SRC

*** hungry-delete

=hungry-delete= will delete all whitespace forward or backward.

#+BEGIN_SRC emacs-lisp
  (require-package 'hungry-delete)
  (global-set-key (kbd "<H-backspace>") 'hungry-delete-backward)
  (global-set-key (kbd "H-d") 'hungry-delete-forward)
#+END_SRC

*** alert

A Growl-like alerts notifier for Emacs.

#+BEGIN_SRC emacs-lisp
  (require-package 'alert)
#+END_SRC

On the mac, we'll use the [[https://github.com/alloy/terminal-notifier][terminal-notifier]] to integrate with [[http://en.wikipedia.org/wiki/Notification_Center][Notification Center]].

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq alert-default-style 'notifier))
#+END_SRC

*** sauron

Event log for emacs. We'll use =alert.el= as the backend so it's integrated with
the host system. Also, we'll try to use sauron in a "pop-up" way, i.e. no
separate frame.

#+BEGIN_SRC emacs-lisp
  (require-package 'sauron)
  (add-hook 'sauron-event-added-functions 'sauron-alert-el-adapter)
  (setq sauron-separate-frame nil)
  (push #'sauron-start after-init-hook)
  (smf/add-launcher "n" 'sauron-toggle-hide-show)
#+END_SRC

*** prodigy

Manage external services from within Emacs.

#+BEGIN_SRC emacs-lisp
  (require-package 'prodigy)
  (smf/add-launcher "d" 'prodigy)
#+END_SRC

Let's start by defining a simple service to run the Mercurial website locally.

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "Mercurial Website"
    :command "python"
    :args '("hgwebsite.py")
    :cwd "~/projects/hgwebsite"
    :tags '(hg python)
    :port 5000
    :kill-signal 'sigkill
    :kill-process-buffer-on-stop t)
#+END_SRC

=imapnotify= is a node app that fires a program (in our case an elisp function)
when new mail is received.

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "OfflineIMAP"
    :command "imapnotify"
    :args '("-c" "~/.config/imapnotify.js")
    :tags '(mail node)
    :kill-signal 'sigkill
    :kill-process-buffer-on-stop t
    :init 'offlineimap)
#+END_SRC

Bitbucket awwwwww yeah

Define a tag so that we can inherit the same env variables

#+BEGIN_SRC emacs-lisp
  (prodigy-define-tag
    :name 'bitbucket
    :cwd "~/projects/bitbucket"
    :path `(,(expand-file-name "~/.virtualenvs/bitbucket/bin")
            ,(expand-file-name "~/projects/go/bin"))
    :kill-signal 'sigkill
    :env `(("BB_EMAIL_PASSWORD"
            ,(smf/get-keychain-password "bbtest@farley.io" "mail.farley.io"))
           ("HGRCPATH" ,(expand-file-name "~/projects/bitbucket-etc/hgrc"))
           ("GIT_CONFIG_NOSYSTEM" "1")
           ("PYTHONUNBUFFERED" "1")
           ("DEBUG" "1")
           ("CELERY_RDB_PORT" "6900")
           ("DJANGO_SETTINGS_MODULE" "bitbucket.settings.dev")
           ("LANG" "en_US.UTF-8")
           ("PATH" ,(concat (expand-file-name "~/projects/go/bin") ":"
                            (expand-file-name "~/.virtualenvs/bitbucket/bin") ":"
                            (getenv "PATH")))
           ("VIRTUAL_ENV" ,(expand-file-name "~/.virtualenvs/bitbucket/"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "Bitbucket Celery"
    :command "python"
    :args '("manage.py" "celeryd" "-l" "DEBUG")
    :tags '(bitbucket python))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "Bitbucket Django"
    :command "python"
    :url "http://dev.bitbucket.org:8000"
    :args '("manage.py" "runserver")
    :tags '(bitbucket python))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "Bitbucket Hgweb"
    :command "gunicorn"
    :args '("--config" "conf/gunicorn-bridgehgweb.conf.py"
            "--bind" "localhost:8001"
            "-w" "1"
            "bridgehgweb:application")
    :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_hgweb"))
    :tags '(bitbucket python))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "Bitbucket Gitweb"
    :command "gunicorn"
    :args '("--config" "conf/gunicorn-gitweb.conf.py"
            "--bind" "localhost:8002"
            "-w" "1"
            "gitweb:application")
    :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_gitweb"))
    :tags '(bitbucket python))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "Bitbucket Conqserver"
    :command "gunicorn"
    :args '("--config" "conf/gunicorn-conqserver.conf.py"
            "--bind" "localhost:9006"
            "-w" "1"
            "conqserver:application")
    :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_conqserver"))
    :tags '(bitbucket))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (prodigy-define-service
    :name "Bitbucket Conker"
    :command "conker"
    :cwd "~/projects/go/src/bitbucket.org/bitbucket/conker"
    :tags '(bitbucket))
#+END_SRC

*** d-mode

An Emacs major mode for editing D code.

#+BEGIN_SRC emacs-lisp
  (require-package 'd-mode)
  (add-to-list 'auto-mode-alist '("\\.d[i]?\\'" . d-mode))
#+END_SRC

Follow-up with a company backend,

#+BEGIN_SRC emacs-lisp
  (require-package 'company-dcd)
  (add-hook 'd-mode-hook 'company-dcd-mode)
#+END_SRC

*** rust-mode

=rust-mode= makes editing Rust code with Emacs enjoyable.

#+BEGIN_SRC emacs-lisp
  (require-package 'rust-mode)
  (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
#+END_SRC

Use =racer= for autocompletion

#+BEGIN_SRC emacs-lisp
  (require-package 'racer)
  (setq racer-rust-src-path "/opt/local/share/rust/src/")
  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode)
#+END_SRC

*** hideshowvis

Enables collapsable regions and diminish the mode:

#+BEGIN_SRC emacs-lisp
  (require-package 'hideshowvis)
  (defun smf/prog-mode-hook ()
    (hideshowvis-enable)
    (diminish 'hs-minor-mode))
  (add-hook 'prog-mode-hook 'smf/prog-mode-hook)
#+END_SRC

*** focus

Dim the font color of text in surrounding paragraphs.

#+BEGIN_SRC emacs-lisp
  (require-package 'focus)
#+END_SRC

*** which-func

=which-func= is a handy mode to display which function you're currently in. I
don't like the '[' and ']' brackets around the function, and also like unknown
functions to be an empty string so [[powerline]] looks even better.

#+BEGIN_SRC emacs-lisp
  (which-function-mode)
  (setq which-func-unknown "")
#+END_SRC

Alternately, I could prefix the function name with "ƒₓ" but I defer that for
now.

*** fic-mode

Show FIXME/TODO/BUG(...) in special face only in comments and strings.

#+BEGIN_SRC emacs-lisp
  (require-package 'fic-mode)
  (add-hook 'prog-mode-hook 'fic-mode)
#+END_SRC

*** rainbow-mode

=rainbow-mode= is a minor mode for Emacs which displays strings representing
colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (require-package 'rainbow-mode)
#+END_SRC

=rainbow-mode= doesn't have a global method, so we'll add a css hook for it,

#+BEGIN_SRC emacs-lisp
  (add-hook 'css-mode-hook 'rainbow-mode)
#+END_SRC

*** less-css-mode

=less-css-mode= is a major mode for Emacs which displays strings representing
colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (require-package 'less-css-mode)
#+END_SRC

*** rainbow-delimiters

=rainbow-delimiters= is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their depth.

#+BEGIN_SRC emacs-lisp
  (require-package 'rainbow-delimiters)
#+END_SRC

Add =rainbow-delimiters= to all programming modes,

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+END_SRC

*** rainbow-blocks

=rainbow-blocks= is an Emacs mode that highlights blocks made of parentheses,
brackets, and braces according to their depth.

#+BEGIN_SRC emacs-lisp
  (require-package 'rainbow-blocks)
#+END_SRC

Add =rainbow-blocks= to programming modes,

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'rainbow-blocks-mode)
  (add-hook 'lisp-interaction-mode-hook 'rainbow-blocks-mode)
#+END_SRC

and diminish the mode:

#+BEGIN_SRC emacs-lisp
  (after-load 'rainbow-blocks
    (after-load 'diminish
      (diminish 'rainbow-blocks-mode)))
#+END_SRC

*** python debugger

#+BEGIN_SRC emacs-lisp
  (require-package 'realgud)
  (require 'realgud)
  (define-key realgud:shortkey-mode-map [mouse-3] 'realgud:tooltip-eval)
  (define-key realgud-track-mode-map (kbd "C-c C-/") 'realgud:ipdb-foo)
#+END_SRC

*** anaconda

=anaconda= is an Emacs package to bring powerful Python editing to Emacs. After
trying other major packages (elpy and jedi) I’ve settled on anaconda-mode and
virtualenvwrapper. It provides a nice mix of tweakability and convenience.

anaconda-mode provides code navigation and docs. Additionally, if company-mode
is enabled, company-anaconda will also be enabled.

#+BEGIN_SRC emacs-lisp
  (require-package 'anaconda-mode)
  (require-package 'company-anaconda)
  (after-load 'company
    (add-to-list 'company-backends 'company-anaconda))
#+END_SRC

Showing the indentation by a vertical highlight line is quite handy for quickly
determining the level of indentation,

#+BEGIN_SRC emacs-lisp
  (require-package 'highlight-indentation)
  (after-load 'highlight-indentation
    (diminish 'highlight-indentation-mode))
#+END_SRC

After a few levels of indirection, =anaconda= has no hope of finding a symbol's
definition, so it gives up. In this case, invoking
`anaconda-mode-find-defintions' will do nothing and show a little error message
in the echo area. When this happens, of course we still want to find what I'm
looking for so we define this function:

#+BEGIN_SRC emacs-lisp
  (defun smf/goto-def-or-dumbjump ()
    "Go to definition of thing at point or do a dumb-jump-go in
    project if that fails"
    (interactive)
    (ring-insert find-tag-marker-ring (point-marker))
    (anaconda-mode-call "goto_definitions"
                        'smf/anaconda-mode-find-definitions-callback))

  (defun smf/anaconda-mode-find-definitions-callback (result)
    "Process find definitions RESULT."
    (let ((old-buffer (current-buffer))
          (old-point (point)))
      (if result
          (progn
            (anaconda-mode-definitions-view result)
            (when (and (eq old-point (point))
                       (equal old-buffer (current-buffer)))
              ;; if we didn't actually jump, then fallback to dumb-jump
              (message nil)             ; clear any failed messages since we're
                                          ; about to try a different jump
              (dumb-jump-go)))
        (dumb-jump-go))))
#+END_SRC

By default, anaconda binds =M-,= to finding assignments instead of popping the
navigation stack (which changed in Emacs 25),

#+BEGIN_SRC emacs-lisp
  (defun smf/test ()
    (interactive)
    (anaconda-mode-find-definitions :async nil))

  (defun smf/anaconda-hook ()
    (define-key anaconda-mode-map (kbd "M-.") 'smf/goto-def-or-dumbjump)
    (define-key anaconda-mode-map (kbd "M-,") nil))
  (add-hook 'python-mode-hook 'smf/anaconda-hook)
#+END_SRC

Add [[anaconda]] to diminish,

#+BEGIN_SRC emacs-lisp
  (after-load 'anaconda-mode
    (diminish 'highlight-indentation-mode)
    (diminish 'anaconda-mode))
#+END_SRC

Now, load anaconda and friends,

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'highlight-indentation-mode)
  (add-hook 'python-mode-hook 'anaconda-mode)
  (add-hook 'python-mode-hook 'eldoc-mode)
#+END_SRC

*** python-switch-quotes

Cycle between apostrophes and quotes in python strings. Converts strings like
'this' to strings like "this".

#+BEGIN_SRC emacs-lisp
  (use-package python-switch-quotes
    :after python
    :ensure t
    :defer t
    :bind (:map python-mode-map
                ("C-c '" . python-switch-quotes)))
#+END_SRC

*** sphinx-doc-mode

[[https://github.com/naiquevin/sphinx-doc.el][sphinx-doc]] is an emacs minor mode for inserting docstring skeleton for Python
functions and methods.

#+BEGIN_SRC emacs-lisp
  (require-package 'sphinx-doc)
  (add-hook 'python-mode-hook 'sphinx-doc-mode)
  (after-load 'sphinx-doc
    (diminish 'sphinx-doc-mode))
#+END_SRC

*** pip

This adds some basic features for requirements files, such as highlighting and
auto-completion of names from PyPI.

#+BEGIN_SRC emacs-lisp
  (require-package 'pip-requirements)
  (add-to-list 'auto-mode-alist '("requirements.*\\.txt" .
                                  pip-requirements-mode))
#+END_SRC

*** Dumb Jump

Dumb Jump is an Emacs "jump to definition" package with support for multiple
programming languages that favors "just working". This means minimal -- and
ideally zero -- configuration with absolutely no stored indexes (TAGS) or
persistent background processes. Dumb Jump requires at least GNU Emacs 24.4.

#+BEGIN_SRC emacs-lisp
  (require-package 'dumb-jump)
  (dumb-jump-mode)
  (setq dumb-jump-selector 'ivy)
#+END_SRC

*** yasnippet

YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates. Bundled language templates
include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more. The
snippet syntax is inspired from [[http://manual.macromates.com/en/snippets][TextMate's]] syntax.

#+BEGIN_SRC emacs-lisp
  (require-package 'yasnippet)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq yas/root-directory (smf/join-dirs smf/dotfiles-dir "snippets"))
  (yas-global-mode 1)
  (diminish 'yas-minor-mode)
#+END_SRC

*** smart-tabs-mode

This mode provides code which improves on Emacs’ auto-indenting, so that
whenever you press the <tab> key, the appropriate amount of tabs and spaces is
inserted automatically. You can still use all spaces if you prefer, of course;
the code merely ensures that if you enable tabs (maybe when maintaining legacy
code), the tab size does not matter.

#+BEGIN_SRC emacs-lisp
  (require-package 'smart-tabs-mode)
#+END_SRC

Enable smart-tabs-mode automatically for C and Javascript,

#+BEGIN_SRC emacs-lisp
  (smart-tabs-insinuate 'c 'javascript)
#+END_SRC

*** guide-key

[[https://github.com/kai2nenobu/guide-key][guide-key]] shows a popup help window after a pressing defined keys for a short
delay.

#+BEGIN_SRC emacs-lisp
  (require-package 'guide-key)
#+END_SRC

Enable it for my [[Launcher keymap]] prefix:

#+BEGIN_SRC emacs-lisp
  (setq guide-key/guide-key-sequence '("C-x C-l" "C-c p" "C-x 4"))
  (guide-key-mode 1)
#+END_SRC

[[diminish]] =guide-key-mode=:

#+BEGIN_SRC emacs-lisp
  (after-load 'diminish
    (diminish 'guide-key-mode))
#+END_SRC

*** browse-kill-ring

[[https://github.com/browse-kill-ring/browse-kill-ring][browse-kill-ring]] allows one to browse the kill ring history when yanking.

#+BEGIN_SRC emacs-lisp
  (require-package 'browse-kill-ring)
#+END_SRC

remap =yank-pop=:

#+BEGIN_SRC emacs-lisp
  (define-key (current-global-map) [remap yank-pop] 'browse-kill-ring)
#+END_SRC

make =browse-kill-ring= act like =yank-pop= by overwriting the previous yank:

#+BEGIN_SRC emacs-lisp
  (after-load 'browse-kill-ring
    (setq browse-kill-ring-replace-yank t))
#+END_SRC

*** narrow-indirect

[[http://www.emacswiki.org/emacs/narrow-indirect.el][narrow-indirect]] allows one to focus a buffer onto some particular code in
another window, editing it separately from its original context ([[http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/][a better
description of this workflow]]).

#+BEGIN_SRC emacs-lisp
  (require-package 'narrow-indirect)
#+END_SRC

*** dtrt-indent

[[https://github.com/jscheid/dtrt-indent][dtrt-indent]] is an Emacs minor mode that guesses the indentation offset
originally used for creating source code files and transparently adjusts the
corresponding settings in Emacs, making it more convenient to edit foreign
files.

#+BEGIN_SRC emacs-lisp
  (require-package 'dtrt-indent)
  (require 'dtrt-indent)
  (dtrt-indent-mode)
  (delq 'dtrt-indent-mode-line-info global-mode-string)
#+END_SRC

*** editorconfig

[[https://github.com/editorconfig/editorconfig-core-c][EditorConfig]] makes it easy to maintain the correct coding style when switching
between different text editors and between different projects.

#+BEGIN_SRC emacs-lisp
  (require-package 'editorconfig)
#+END_SRC

*** js2-mode

Improved JavaScript editing mode for GNU Emacs.

#+BEGIN_SRC emacs-lisp
  (setq js2-basic-offset 2)
  (setq js-indent-level 2)
  (require-package 'js2-mode)
#+END_SRC

*** skewer-mode

[[https://github.com/skeeto/skewer-mode][Skewer]]: live web development with Emacs.

#+BEGIN_SRC emacs-lisp
  (require-package 'skewer-mode)
#+END_SRC

*** impatient-mode

See the effect of your HTML as you type it.

#+BEGIN_SRC emacs-lisp
  (require-package 'impatient-mode)
#+END_SRC

*** json-mode

Sure, why not.

#+BEGIN_SRC emacs-lisp
  (require-package 'json-mode)
  (setq json-reformat:indent-width 2)
#+END_SRC

*** go-mode

Blergh.

#+BEGIN_SRC emacs-lisp
  (require-package 'go-mode)
#+END_SRC

*** groovy-mode

Why.

#+BEGIN_SRC emacs-lisp
  (require-package 'groovy-mode)
#+END_SRC

*** lua-mode

Dear god.

#+BEGIN_SRC emacs-lisp
  (require-package 'company-lua)
#+END_SRC

*** anzu

[[https://github.com/syohex/emacs-anzu][anzu]] provides enhancements to =isearch= and related tasks, particularly
providing counts and better replacement visualisation.

#+BEGIN_SRC emacs-lisp
  (require-package 'anzu)
  (require 'anzu)
#+END_SRC

Enable [[anzu]] globally,

#+BEGIN_SRC emacs-lisp
  (global-anzu-mode +1)
#+END_SRC

Use [[anzu]]'s better =query-replace= and =query-replace-regexp=:

#+BEGIN_SRC emacs-lisp
    (define-key (current-global-map) [remap query-replace] 'anzu-query-replace)
    (define-key (current-global-map) [remap query-replace-regexp]
      'anzu-query-replace-regexp)
#+END_SRC

Hide [[anzu]]'s mode,

#+BEGIN_SRC emacs-lisp
  (after-load 'diminish
    (diminish 'anzu-mode))
#+END_SRC

*** move-text

#+BEGIN_SRC emacs-lisp
  (require-package 'move-text)
  (move-text-default-bindings)
#+END_SRC

*** C/C++/ObjC

Trying out irony mode

#+BEGIN_SRC emacs-lisp
  (require-package 'irony-eldoc)
  (require-package 'company-irony)
  (require-package 'company-irony-c-headers)
  (require-package 'flycheck-irony)
  (require-package 'rtags)
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'objc-mode-hook 'irony-mode)
  (add-hook 'c++-mode-hook 'rtags-start-process-unless-running)
  (add-hook 'c-mode-hook 'rtags-start-process-unless-running)
  (add-hook 'objc-mode-hook 'rtags-start-process-unless-running)

  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))

  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

  (after-load 'company
    (add-to-list 'company-backends '(company-irony-c-headers company-irony)))

  (eval-after-load 'flycheck
    '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))

  (setq c-default-style "linux")
#+END_SRC

*** function-args

GNU Emacs package for showing an inline arguments hint for the C/C++ function
at point.

#+BEGIN_SRC emacs-lisp
(require-package 'function-args)
(fa-config-default)
#+END_SRC emacs-lisp

*** xcode-mode

#+BEGIN_SRC emacs-lisp
  (if (file-accessible-directory-p "~/sandbox/xcode-mode")
      (progn
        (smf/add-to-load-path "~/sandbox/xcode-mode")
        (require-package 'ecukes)
        (require-package 'espuds)
        (require 'xcode-mode)))
#+END_SRC

*** aHg

#+BEGIN_SRC emacs-lisp
  (if (file-accessible-directory-p "~/projects/ahg")
      (smf/add-to-load-path "~/projects/ahg")
    (require-package 'ahg))
  (require 'ahg)
#+END_SRC

*** hg-test-mode

A mode for Mercurial test files

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/hg-test-mode")
#+END_SRC

*** git-commit

This package assists the user in writing good Git commit messages.

#+BEGIN_SRC emacs-lisp
(require-package 'git-commit)
(require 'git-commit)
#+END_SRC

*** gitconfig-mode

A major mode for editing .gitconfig files.

#+BEGIN_SRC emacs-lisp
  (require-package 'gitconfig-mode)
#+END_SRC

*** git-gutter

Emacs port of GitGutter which is Sublime Text Plugin.

#+BEGIN_SRC emacs-lisp
  (require-package 'git-gutter)
  (setq git-gutter:handled-backends '(git hg))
  (global-git-gutter-mode +1)
  (diminish 'git-gutter-mode)
#+END_SRC

*** magit

[[https://github.com/magit/magit][Magit]] is an Emacs interface to Git. It's very feature-rich and I find it
intuitive.

**** Keyboard shortcuts

=magit-status= is the main command to launch Magit. It's =autoloaded= so I don't
need to load Magit first.

#+BEGIN_SRC emacs-lisp
  (smf/add-launcher "g" 'magit-status)
#+END_SRC

=magit-grep= isn't =autoloaded=, so I need to explicitly load it before binding
it:

#+BEGIN_SRC emacs-lisp
  (autoload 'magit-grep "magit" "Grep for files" t)
  (global-set-key (kbd "C-c f") 'magit-grep)
#+END_SRC

**** Configuration

When performing a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]] within Magit, I'd like to use IDO:

#+BEGIN_SRC emacs-lisp
  (setq magit-completing-read-function 'magit-ido-completing-read)
#+END_SRC

Open the =magit-status= buffer in the same window as the current buffer:

#+BEGIN_SRC emacs-lisp
  (setq magit-status-buffer-switch-function 'switch-to-buffer)
#+END_SRC

Highlight individual word and letter changes when showing hunk diff overlays:

#+BEGIN_SRC emacs-lisp
  (setq magit-diff-refine-hunk t)
#+END_SRC

Don't tell me when Magit reverts buffers:

#+BEGIN_SRC emacs-lisp
  (setq magit-revert-buffers 'silent)
#+END_SRC

When Magit takes a while to call out to Git, pop the process buffer after 10
seconds so I can look for issues:

#+BEGIN_SRC emacs-lisp
  (setq magit-process-popup-time 10)
#+END_SRC

Always show the =verbose= diff in commit windows:

#+BEGIN_SRC emacs-lisp
  (setq magit-commit-arguments '("--verbose"))
#+END_SRC

Always set the upstream when pushing:

#+BEGIN_SRC emacs-lisp
  (setq magit-push-arguments '("--set-upstream"))
#+END_SRC

Ugh, stupid git

#+BEGIN_SRC emacs-lisp
  (setq git-commit-summary-max-length 72)
#+END_SRC

**** Load Magit

Finally we can install Magit:

#+BEGIN_SRC emacs-lisp
  (require-package 'magit)
#+END_SRC

*** hugme

An experimental fork of magit for Mercurial. Most of the things here won't work.

**** Keyboard shortcuts

=hugme-status= is the main command to launch Magit. It's =autoloaded= so I don't
need to load Magit first.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c h") 'hugme-status)
#+END_SRC

=hugme-grep= isn't =autoloaded=, so I need to explicitly load it before binding
it:

#+BEGIN_SRC emacs-lisp
  (autoload 'hugme-grep "hugme" "Grep for files" t)
#+END_SRC

**** Configuration

When performing a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]] within Hugme, I'd like to use IDO:

#+BEGIN_SRC emacs-lisp
  (setq hugme-completing-read-function 'hugme-ido-completing-read)
#+END_SRC

Open the =hugme-status= buffer in the same window as the current buffer:

#+BEGIN_SRC emacs-lisp
  (setq hugme-status-buffer-switch-function 'switch-to-buffer)
#+END_SRC

Highlight individual word and letter changes when showing hunk diff overlays:

#+BEGIN_SRC emacs-lisp
  (setq hugme-diff-refine-hunk t)
#+END_SRC

Don't tell me when Hugme reverts buffers:

#+BEGIN_SRC emacs-lisp
  (setq hugme-revert-buffers 'silent)
#+END_SRC

When Hugme takes a while to call out to Git, pop the process buffer after 10
seconds so I can look for issues:

#+BEGIN_SRC emacs-lisp
  (setq hugme-process-popup-time 10)
#+END_SRC

Don't prompt me to confirm a canceled histedit,

#+BEGIN_SRC emacs-lisp
  (setq hg-histedit-confirm-cancel nil)
#+END_SRC

Shelling out to hg is expensive, so until we use something like the command
server, set a high-timeout for diffs:

#+BEGIN_SRC emacs-lisp
  (setq hugme-diff-expansion-threshold 10.0)
#+END_SRC

Definitely need to enable debugging while writing this package,

#+BEGIN_SRC emacs-lisp
  (setq hugme-hg-debug t)
#+END_SRC

Experimentally try to use chg, though it doesn't seem to improve the speed of
shelling out,

#+BEGIN_SRC emacs-lisp
  (setq hugme-hg-executable "chg")
#+END_SRC

**** Load Magit

Finally we can load Hugme:

#+BEGIN_SRC emacs-lisp
  (if (file-accessible-directory-p "~/projects/hugme/lisp")
      (progn
        (smf/add-to-load-path "~/projects/hugme/lisp")
        (require 'hugme)))
#+END_SRC

*** emacs-git-messenger

#+BEGIN_SRC emacs-lisp
  (require-package 'git-messenger)
  (setq git-messenger:show-detail 't)
  (after-load 'git-messenger
      (smf/add-launcher "v" 'git-messenger:popup-message))
#+END_SRC

*** slime-nav

Slime allows very convenient navigation to the symbol at point (using M-.), and
the ability to pop back to previous marks (using =M-,=).

This plugin provides similar navigation for Emacs Lisp, supporting navigation
to the definitions of variables, functions, libraries and faces.

#+BEGIN_SRC emacs-lisp
  (require-package 'elisp-slime-nav)
  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
    (add-hook hook 'elisp-slime-nav-mode))
  (after-load 'elisp-slime-nav
    (diminish 'elisp-slime-nav-mode))
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (require-package 'multiple-cursors)
  (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
#+END_SRC

*** Docker

#+BEGIN_SRC emacs-lisp
  (require-package 'docker)
  (require-package 'dockerfile-mode)
  (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
#+END_SRC

*** Twitter

=Twittering-mode=: a Twitter client for Emacs

#+BEGIN_SRC emacs-lisp
  (require-package 'twittering-mode)
  (setq twittering-icon-mode t)
  (setq twittering-use-icon-storage t)
  (smf/add-launcher "t" 'twit)
#+END_SRC

** LaTeX

I love [[http://en.wikipedia.org/wiki/LaTeX][LaTex]]. It's the best way to typeset a document.

*** AucTeX

Let's start by installing some LaTeX specific plugins (mostly AucTex-related)
and initialize them,

#+BEGIN_SRC emacs-lisp
  (require-package 'auctex)
  (require-package 'auctex-latexmk)

  (auctex-latexmk-setup)
#+END_SRC

A few basic settings,

#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq LaTeX-item-indent 0)
  (setq TeX-clean-confirm nil) ;; don't ask me to clean
#+END_SRC

Who uses dvi?

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

*** SyncTeX

[[http://mactex-wiki.tug.org/wiki/index.php/SyncTeX][SyncTeX]] enables synchronization between source TeX files and the resulting pdf
file.

#+BEGIN_SRC emacs-lisp
  (setq TeX-source-correlate-method 'synctex)
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
#+END_SRC

*** Latexmk

[[http://users.phys.psu.edu/~collins/software/latexmk-jcc/][Latexmk]] is a handy way to compile the TeX source the correct number of times.
So, we'll create a convenient binding for that,

#+BEGIN_SRC emacs-lisp
(defun smf/latexmk-compile ()
      (interactive)
      (save-buffer)
      (TeX-command "LatexMk" 'TeX-master-file -1))
#+END_SRC

*** =magic-latex-buffer=

Magical syntax highlighting for LaTeX-mode buffers.

#+BEGIN_SRC emacs-lisp
  (require-package 'magic-latex-buffer)
  (require 'magic-latex-buffer)
#+END_SRC

*** OS X

Sensible defaults for OS X, other OSes should be covered out-of-the-box,

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq TeX-view-program-selection
          '((output-dvi "DVI Viewer")
            (output-pdf "PDF Viewer")
            (output-html "HTML Viewer")))

    (setq TeX-view-program-list
          '(("DVI Viewer" "$HOME/.edit.sh -n %o")
            ("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b %n %o %b")
            ("HTML Viewer" "open %o"))))
#+END_SRC

Modes to load,

#+BEGIN_SRC emacs-lisp
  (defun smf/latex-mode-hook ()
    (turn-on-auto-fill)
    (abbrev-mode +1)
    (LaTeX-math-mode 1)
    (outline-minor-mode 1)
    (magic-latex-buffer)
    (define-key LaTeX-mode-map (kbd "C-c C-a") 'smf/latexmk-compile)
    (diminish 'magic-latex-buffer)
    (diminish 'iimage-mode)
    (diminish 'outline-minor-mode)
    (diminish 'reftex-mode)
    (diminish 'abbrev-mode))

  (add-hook 'LaTeX-mode-hook 'smf/latex-mode-hook)
  (add-hook 'LaTeX-mode-hook 'reftex-mode)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)   ; with AUCTeX LaTeX mode
  (add-hook 'latex-mode-hook 'turn-on-reftex)   ; with Emacs latex mode
#+END_SRC

*** RefTeX

You know what eles is awesome? [[http://www.gnu.org/software/auctex/reftex.html][RefTeX]].

#+BEGIN_SRC emacs-lisp
  (autoload 'reftex-mode "reftex" "RefTeX Minor Mode" t)
  (autoload 'reftex-citation "reftex-cite" "Make citation" nil)
  (autoload 'reftex-index-phrase-mode "reftex-index" "Phrase mode" t)
#+END_SRC

These settings were randomly found,

#+BEGIN_SRC emacs-lisp
  (setq reftex-enable-partial-scans t)
  (setq reftex-save-parse-info t)
  (setq reftex-use-multiple-selection-buffers t)
  (setq reftex-plug-into-AUCTeX t)

  (setq reftex-cite-prompt-optional-args nil)
  (setq reftex-cite-cleanup-optional-args t)

  (setq reftex-section-levels
   '(("part" . 0) ("chapter" . 1) ("section" . 2) ("subsection" . 3)
     ("frametitle" . 4) ("subsubsection" . 4) ("paragraph" . 5)
     ("subparagraph" . 6) ("addchap" . -1) ("addsec" . -2)))

  (setq reftex-plug-into-AUCTeX t
        reftex-extra-bindings t
        reftex-bibfile-ignore-list nil
        reftex-guess-label-type t
        reftex-revisit-to-follow t
        reftex-use-fonts t   ; make colorful toc
        reftex-toc-follow-mode nil ; don't follow other toc(s)
        reftex-toc-split-windows-horizontally t
        reftex-auto-recenter-toc t
        reftex-enable-partial-scans t
        reftex-save-parse-info t
        reftex-use-multiple-selection-buffers t)
#+END_SRC

*** Folding

#+BEGIN_SRC emacs-lisp
  (setq outline-minor-mode-prefix (kbd "\C-co"))

  (setq TeX-fold-env-spec-list
        (quote (("[comment]" ("comment"))
                ("[figure]" ("figure"))
                ("[table]" ("table"))
                ("[itemize]" ("itemize"))
                ("[enumerate]" ("enumerate"))
                ("[description]" ("description"))
                ("[overpic]" ("overpic"))
                ("[tabularx]" ("tabularx"))
                ("[code]" ("code"))
                ("[shell]" ("shell")))))
#+END_SRC

*** Guessing the master TeX file

Taken from [[http://www.emacswiki.org/AUCTeX#toc19][EmacsWiki]] for automatic detection of the master file,

#+BEGIN_SRC emacs-lisp
  (defun smf/guess-TeX-master (filename)
     "Guess the master file for FILENAME from currently open .tex files."
     (let ((candidate nil)
           (filename (file-name-nondirectory filename)))
       (save-excursion
         (dolist (buffer (buffer-list))
           (with-current-buffer buffer
             (let ((name (buffer-name))
                   (file buffer-file-name))
               (if (and file (string-match "\\.tex$" file))
                   (progn
                     (goto-char (point-min))
                     (if (re-search-forward (concat "\\\\input{" filename "}") nil t)
                         (setq candidate file))
                     (if (re-search-forward (concat "\\\\include{" (file-name-sans-extension filename) "}") nil t)
                         (setq candidate file))))))))
       (if candidate
           (message "TeX master document: %s" (file-name-nondirectory candidate)))
       candidate))

 (add-hook 'LaTeX-mode-hook
  '(lambda ()
    (setq TeX-master (smf/guess-TeX-master (buffer-file-name)))))
#+END_SRC

*** company-math

#+BEGIN_SRC emacs-lisp
  (require-package 'company-auctex)
  (require-package 'company-math)

  (company-auctex-init)
  (add-to-list 'company-backends 'company-math-symbols-unicode)
#+END_SRC

*** pdf-tools

#+BEGIN_SRC emacs-lisp
  (require-package 'pdf-tools)
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
#+END_SRC

** Loading Themes

On a GUI Emacs, I want to use the [[zenburn-theme]]. On a terminal I want to use the
[[base16-theme]].

*CAVEAT*

We need to load the theme after AUCTeX but before ERC. Why? I don't really know
but I do know it messes up erc-hl-nicks if I don't do it this way.

*** spaceline

#+BEGIN_SRC emacs-lisp
  ;; (use-package powerline
  ;;   :if window-system
  ;;   :config (setq-default powerline-default-separator 'nil))

  ;; (use-package spaceline-all-the-icons :after spaceline
  ;;   :load-path "init")

  ;;    (smf/add-to-load-path "~/.emacs.d/init")

  (setq custom-safe-themes t)

  (use-package powerline
    :if window-system
    :config (setq-default powerline-default-separator 'nil))

  (use-package spaceline-custom
    :after spaceline-colors
    :demand
    :load-path "init"
    :init (add-hook 'after-init-hook 'spaceline-update-faces)
    :config (advice-add 'load-theme :after 'spaceline-update-faces)
    )

  (use-package spaceline-colors
    :after spaceline
    :load-path "init"
    :demand
    )

  (use-package spaceline
    :after powerline
    :demand
    :ensure t
    :config (setq-default mode-line-format
                          '("%e" (:eval (spaceline-ml-ati)))))


  ;; Themed with Spaceline
  (use-package gruvbox-theme :ensure t :defer t)
  (use-package creamsody-theme :ensure t)
  (use-package suscolors-theme :ensure t :defer t)
  (use-package atom-one-dark-theme :ensure t :defer t)
  (use-package forest-blue-theme :ensure t :defer t)
  (use-package liso-theme :ensure t :defer t)
  (use-package peacock-theme :ensure t :defer t)
  (use-package solarized-theme :ensure t :defer t)

  (defun remove-mode-line-box (&rest args)
    (set-face-attribute 'mode-line nil :box nil :underline nil)
    (set-face-attribute 'mode-line-inactive nil :box nil :underline nil))

  (when window-system
    (remove-mode-line-box)
    (load-theme 'creamsody))
#+END_SRC

** ERC

*** Setup

[[http://en.wikipedia.org/wiki/Internet_Relay_Chat][IRC]] is still popular, so we'll use Emacs IRC.

#+BEGIN_SRC emacs-lisp
  (require 'tls)
  (require 'erc)
  (require 'erc-join)
  (require 'erc-menu)
  (require-package 'erc-hl-nicks)
  (require-package 'erc-tweet)
  (require-package 'znc)
  (require-package 'cloud-to-butt-erc)
  (require-package 'erc-hipchatify)
#+END_SRC

I use [[http://wiki.znc.in/ZNC][ZNC]] to always stay connected to IRC channels, so when I close a buffer I
don't want to quit the channel, just detach from my server. Also, we use the
keychain method defined above to get our password.

#+BEGIN_SRC emacs-lisp
  (setq
   znc-detatch-on-kill t
   znc-servers `(
                 ("smf.io" "6697" t ((freenode "smf/freenode"
                                               ,(smf/get-keychain-password "smf" "smf.io"))))
                 ("smf.io" "6697" t ((bitlbee "smf/bitlbee"
                                              ,(smf/get-keychain-password "smf" "smf.io"))))))
#+END_SRC

Some basic settings about my IRC setup,

#+BEGIN_SRC emacs-lisp
  (setq
   erc-prompt ">"
   erc-email-userid "sean.michael.farley@gmail.com"
   erc-autojoin-channels-alist '((".*smf.io.*" "&bitlbee" "#bitbucket"))
   erc-prompt-for-password nil
   erc-prompt-for-nickserv-password nil
   erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                             "324" "329" "332" "333" "353" "477")
   erc-hide-list '("JOIN" "PART" "QUIT")
   erc-quit-reason 'erc-quit-reason-normal
   erc-track-exclude-server-buffer t

   ;; this changed in emacs 25 ... I still prefer monospaced fonts
   shr-use-fonts nil)
#+END_SRC

I found when having a flaky connection that ERC would attempt to reconnect ad
infinitum, so we turn that off,

#+BEGIN_SRC emacs-lisp
  (setq erc-server-auto-reconnect nil)
#+END_SRC

The following makes colors look nice with [[zenburn]].

#+BEGIN_SRC emacs-lisp
  (setq erc-hl-nicks-color-contrast-strategy '(invert contrast))
#+END_SRC

While we're at it, let's enable [[http://www.emacswiki.org/emacs/ErcDCC][direct client-to-client]],

#+BEGIN_SRC emacs-lisp
  (add-to-list 'erc-modules 'dcc)
  (add-to-list 'erc-modules 'hipchatify)
  (add-to-list 'erc-modules 'tweet)
  (erc-update-modules)
#+END_SRC

Spelling mode is exactly what it says it is,

#+BEGIN_SRC emacs-lisp
  (erc-spelling-mode 1)
#+END_SRC

*** Query behavior

Button mode allows you to click on a nick and open a new query,

#+BEGIN_SRC emacs-lisp
  (erc-button-mode 1)
#+END_SRC

Set the token for HipChat api calls,

#+BEGIN_SRC emacs-lisp
  (setq erc-hipchatify-token `,(smf/get-keychain-password "smf/token" "hipchat.com"))
#+END_SRC

Set the email for HipChat,

#+BEGIN_SRC emacs-lisp
  (setq erc-hipchatify-email "sfarley@atlassian.com")
#+END_SRC

Set the channel names (buffer names) for which to replace 'nick' with '@nick',

#+BEGIN_SRC emacs-lisp
  (setq erc-hipchatify-mention-channels '("smf"
                                          "#bitbucket-social"
                                          "#bitbucket-cloud"
                                          "#bitbucket-support"
                                          "#bitbucket-bugfix"
                                          "#bitbucket-sf"
                                          "#bitbucket-ops"
                                          "#sourcetree"))
#+END_SRC

When people send me a message (called 'query' in IRC speak), I want the buffer
to pop up and notify me,

#+BEGIN_SRC emacs-lisp
  (setq erc-auto-query 'buffer)
  (setq erc-query-display 'buffer)
#+END_SRC

As a default, only private messages trigger automatic creation of query buffers.
I want the same behavior when I receive all notices (from [[http://www.emacswiki.org/emacs/ErcAutoQuery][EmacsWiki]]),

#+BEGIN_SRC emacs-lisp
  (add-hook 'erc-after-connect
            (lambda (server nick)
              (add-hook 'erc-server-NOTICE-hook 'erc-auto-query)))
#+END_SRC

Turn on =company-mode= by default for erc,

#+BEGIN_SRC emacs-lisp
  (add-hook 'erc-mode-hook 'company-mode)
#+END_SRC

*** Switch to buffer or connect to znc

If I haven't connected to my ZNC server, then we connect to it; otherwise, just
switch to the buffer.

#+BEGIN_SRC emacs-lisp
  (defun smf/erc-start-or-switch (channel)
    "Connect to ERC, or switch to given channel"
    (interactive)
    (if (get-buffer "*irc-freenode*") ;; ERC already active?
        (progn
          (set-buffer "*irc-freenode*")
          (if (erc-server-process-alive)
              (switch-to-buffer channel) ;; yes: switch to #channel
            (znc-all)))                  ;; no: start ERC
      (znc-all)))                        ;; no: start ERC

  (defun smf/bitbucket ()
    (interactive)
    (smf/erc-start-or-switch "#bitbucket"))

  (defun smf/mercurial ()
    (interactive)
    (smf/erc-start-or-switch "#mercurial"))

  (defun smf/disable-chat ()
    (interactive)
    (znc-all t)
    (define-key smf/launcher-map "b" nil)
    (define-key smf/launcher-map "m" nil)
    (message "Disabled ERC/ZNC"))

  (defun smf/enable-chat ()
    (interactive)
    (define-key smf/launcher-map "b" 'smf/bitbucket)
    (define-key smf/launcher-map "m" 'smf/mercurial)
    (message "Enabled ERC/ZNC"))
  (smf/enable-chat)
#+END_SRC

*** Query any user

Below adds the ability to launch a new chat with any nick. It amalgamates all
nicks in all channels because that is simple and hasn't been a problem for me
yet. My [[http://www.bitlbee.org][BitlBee]] server appends "|fb" or "|gtalk" for the corresponding chat
method so that takes care of most potential name conflicts.

#+BEGIN_SRC emacs-lisp
  (defun smf/user-keys (erc-channel-users)
  "Convert the ERC-CHANNEL-USERS hash into an equivalent list-based form."
  (let ((alist '()))
    (maphash (lambda (key value)
               (push (erc-server-user-nickname (car value)) alist))
             erc-channel-users)
    alist))

  (defun smf/buffer-users (buffer)
    "Return users for a given ERC buffer"
    (set-buffer buffer)
    (smf/user-keys erc-channel-users))

  (defun smf/erc-chat (nick)
    "Start a query with nick"
    (interactive
     (list (completing-read "Nick: "
                            (append (smf/buffer-users "&bitlbee")
                                    (smf/buffer-users "#mercurial")
                                    (smf/buffer-users "#bitbucket")))))
    (cond ((member nick (smf/buffer-users "&bitlbee"))
           (set-buffer "&bitlbee"))
          ((member nick (smf/buffer-users "#mercurial"))
           (set-buffer "#mercurial"))
          ((member nick (smf/buffer-users "#bitbucket"))
           (set-buffer "#bitbucket")))

    (erc-cmd-QUERY nick))

  (smf/add-launcher "c" 'smf/erc-chat)
#+END_SRC

*** Better ERC Scrolling

Deniz Dogan [[http://lists.gnu.org/archive/html/bug-gnu-emacs/2012-06/msg00360.html][saves the day]] with some awesome improvements to scrolling.

#+BEGIN_SRC emacs-lisp
  (defun erc-display-line-1 (string buffer)
    "Display STRING in `erc-mode' BUFFER.
  Auxiliary function used in `erc-display-line'.  The line gets filtered to
  interpret the control characters.  Then, `erc-insert-pre-hook' gets called.
  If `erc-insert-this' is still t, STRING gets inserted into the buffer.
  Afterwards, `erc-insert-modify' and `erc-insert-post-hook' get called.
  If STRING is nil, the function does nothing."
    (when string
      (with-current-buffer (or buffer (process-buffer erc-server-process))
        (let ((insert-position (or (marker-position erc-insert-marker)
                                   (point-max))))
          (let ((string string) ;; FIXME! Can this be removed?
                (buffer-undo-list t)
                (inhibit-read-only t))
            (unless (string-match "\n$" string)
              (setq string (concat string "\n"))
              (when (erc-string-invisible-p string)
                (erc-put-text-properties 0 (length string)
                                         '(invisible intangible) string)))
            (erc-log (concat "erc-display-line: " string
                             (format "(%S)" string) " in buffer "
                             (format "%s" buffer)))
            (setq erc-insert-this t)
            (run-hook-with-args 'erc-insert-pre-hook string)
            (if (null erc-insert-this)
                ;; Leave erc-insert-this set to t as much as possible.  Fran
                ;; Litterio <franl> has seen erc-insert-this set to nil while
                ;; erc-send-pre-hook is running, which should never happen.  This
                ;; may cure it.
                (setq erc-insert-this t)
              (save-excursion ;; to restore point in the new buffer
                (save-restriction
                  (widen)
                  (goto-char insert-position)
                  (insert-before-markers string)
                  ;; run insertion hook, with point at restored location
                  (save-restriction
                    (narrow-to-region insert-position (point))
                    (run-hooks 'erc-insert-modify-hook)
                    (run-hooks 'erc-insert-post-hook)
                    (when erc-remove-parsed-property
                      (remove-text-properties (point-min) (point-max)
                                              '(erc-parsed nil))))))))
          (erc-update-undo-list (- (or (marker-position erc-insert-marker)
                                       (point-max))
                                   insert-position)))
        (run-hooks 'erc-display-post-hook)))) ;;; this line and only this line was added

  (defvar erc-display-post-hook nil
    "New hook!")

  (defun smf/erc-display-post-hook ()
    (let ((windows (get-buffer-window-list (current-buffer) nil 'visible)))
      (dolist (w windows)
        (when (>= (point) erc-input-marker)
          (with-selected-window w
            (recenter -1))))))
  (add-hook 'erc-display-post-hook 'smf/erc-display-post-hook)

  (defun smf/erc-send-post-hook ()
    (when (>= (point) erc-input-marker)
      (goto-char (point-max))
      (widen)
      (recenter -1)))
  (add-hook 'erc-send-post-hook 'smf/erc-send-post-hook)

  (defun smf/window-configuration-change-hook ()
    (when (and (eq major-mode 'erc-mode)
               (>= (point) erc-input-marker))
      (recenter -1)))
  (add-hook 'window-configuration-change-hook 'smf/window-configuration-change-hook)
#+END_SRC

*** highlight possessive form

Currently, this is a hack to test highlighting a nick with "'s" at the end.

#+BEGIN_SRC emacs-lisp
  (after-load 'erc-hl-nicks
    (defun erc-hl-nicks ()
      "Retrieves a list of usernames from the server and highlights them"
      (save-excursion
        (with-syntax-table erc-button-syntax-table
          (let ((inhibit-field-text-motion t))
            (goto-char (point-min))
            (while (forward-word 1)
              (let ((word (word-at-point)))
                (when word
                  (let* ((bounds (bounds-of-thing-at-point 'word))
                         (endpt (cdr bounds))
                         (word (if (string-match-p "'s$" word)
                                   (progn
                                     (setq endpt (- endpt 2))
                                     (replace-regexp-in-string "\\('s\\)$" "" word))
                                 word))
                         (trimmed (erc-hl-nicks-trim-irc-nick word))
                         (inhibit-read-only t))
                    (when (erc-hl-nicks-highlight-p word trimmed bounds)
                      (erc-button-add-face (car bounds) endpt
                                           'erc-nick-default-face)
                      (erc-button-add-face (car bounds) endpt
                                           (erc-hl-nicks-make-face trimmed))))))))))))
#+END_SRC

*** Mark buffer as read

Whenever we're done reading a conversation, just hit =Esc=. The buffer will be
buried, and next time we open it again everything we have read before will be
marked in grey.

#+BEGIN_SRC emacs-lisp
  (defun smf/mark-read ()
    "Mark buffer as read up to current line."
    (interactive)
    (let ((inhibit-read-only t))
      (put-text-property
       (point-min) (line-beginning-position)
       'face       'font-lock-comment-face)))

  (defun smf/bury-buffer ()
    "Bury buffer and maybe close its window."
    (interactive)
    (smf/mark-read)
    (bury-buffer))

  (after-load 'erc
    (define-key erc-mode-map (kbd "<escape>") #'smf/bury-buffer)
    (define-key erc-mode-map (kbd "C-'") 'smf/mark-read))
#+END_SRC

** notmuch

[[https://notmuchmail.org][notmuch]] is a mail indexer and searching. It comes with an emacs client.
We only load it if it exists on the system (by wrapping it with =after-load=).

*** Setup

#+BEGIN_SRC emacs-lisp
  (require-package 'notmuch)
  (require 'smtpmail-async)
#+END_SRC

If available, let's use imagemagick.

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types)))
#+END_SRC

Set my main email address (others are set in notmuch-config),

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (setq
     user-mail-address "sean@farley.io"
     user-full-name  "Sean Farley"))
#+END_SRC

*** Address completion

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (setq notmuch-address-command "notmuch-addrlookup"))
#+END_SRC

*** Reply with custom from address

By default, I want my reply email to be the correct one. For example, if I am
replying to an email sent to the MacPorts list then I want =sean@macports.org=
to be used. To achieve this, I wrote a function to handle it:

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (require-package 'gnus-alias)

    (setq

     notmuch-always-prompt-for-sender 't
     gnus-alias-identity-alist
     '(("home"
        nil ;; Does not refer to any other identity
        "Sean Farley <sean@farley.io>" ;; Sender address
        nil ;; No organization header
        nil ;; No extra headers
        nil ;; No extra body text
        nil) ;; No signature)
       ("macports"
        nil
        "Sean Farley <sean@macports.org>"
        nil
        nil
        nil
        nil)
       ("atlassian"
        nil
        "Sean Farley <sfarley@atlassian.com>"
        nil
        nil
        nil
        nil)
       ("lsmsa"
        nil
        "Sean Farley <sean@lsmsa.net>"
        nil
        nil
        nil
        nil))

     ;; prevent replies from showing up in the inbox
     notmuch-fcc-dirs "sent -unread"

     gnus-alias-default-identity "home"

     gnus-alias-identity-rules
     '(
       ("macports"  ("any" "macports" both) "macports")
       ("lsmsa"  ("any" "lsmsa" both) "lsmsa")
       ("atlassian"  ("any" "atlassian" both) "atlassian")
       )
     )

    (add-hook 'message-setup-hook 'gnus-alias-determine-identity))
#+END_SRC

Also, when composing an email, turn on spellchecking:

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (add-hook 'notmuch-message-mode-hook (lambda ()
                                           (auto-fill-mode)
                                           (flyspell-mode))))
#+END_SRC

*** Miscellaneous setting

Set =notmuch= as default emacs email program,

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (setq mail-user-agent 'notmuch-user-agent))
#+END_SRC

Set =offlineimap= to be called for fetching new mail. This allows mail to be
updated from within [[notmuch]] with keyboard shortcuts.

#+BEGIN_SRC emacs-lisp
  (require-package 'offlineimap)
  (after-load 'offlineimap
    (setq offlineimap-mode-line-text nil)
    (setq offlineimap-mode-line-symbols '((run . "⟲")
                                          (stop .  "↻")
                                          (exit .  "■")
                                          (signal . "⚑")
                                          (open .  "⊙")
                                          (listen . "⌥")
                                          (closed . "●")
                                          (connect . "…")
                                          (failed . "⌁"))))

  (after-load 'notmuch
    ;; For some reason this causes the offlineimap-hook to display the
    ;; notmuch-hello buffer
    (setq notmuch-hello-auto-refresh 'nil)

    ;; Add a hook to get news after offlineimap is finished
    (add-hook 'offlineimap-event-hooks (lambda (msg-type &optional action)
                                         (when (and (equal "finished\n" msg-type)
                                                    (get-buffer "*notmuch-hello*"))
                                           (notmuch-hello 't))))

    (define-key notmuch-hello-mode-map "G" 'offlineimap)
    (define-key notmuch-search-mode-map "G" 'offlineimap))
#+END_SRC

Miscellaneous settings: these variable names speak for themselves,

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (setq

       notmuch-archive-tags '("-inbox" "-unread" "+archive")

       ;; smtp mail setting
       send-mail-function    'async-smtpmail-send-it
       message-send-mail-function 'async-smtpmail-send-it
       smtpmail-default-smtp-server "mail.farley.io"
       smtpmail-smtp-server  "mail.farley.io"
       smtpmail-stream-type  'starttls
       smtpmail-smtp-service 587

       ;; don't keep message buffers around
       message-kill-buffer-on-exit t))
#+END_SRC

*** HTML emails

[[http://ergoemacs.org/emacs/emacs24.4_features.html][Emacs 24]] comes with a built-in web browser called [[http://ergoemacs.org/emacs/emacs_eww_web_browser.html][eww]]. By default, =notmuch=
uses this to render html email, so nothing needs to be done. This isn't always
perfect, so to view the html part in an external view, just click on the
text/html part and issue =. o=.

*** Custom actions

=notmuch= doesn't have a keybinding for deleting messages, so we add one:

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    ;; 'd' delete stuff in both search and show mode
    (define-key notmuch-show-mode-map "d"
      (lambda ()
        "Move message to trash."
        (interactive)
        (notmuch-show-tag-all (list "+trash" "-inbox" "-unread" "-archive"))
        (notmuch-show-next-thread t)))
    (define-key notmuch-search-mode-map "d"
      (lambda ()
        "Move message to trash."
        (interactive)
        (notmuch-search-tag (list "+trash" "-inbox" "-unread" "-archive"))
        (next-line))))
#+END_SRC

Also, let's add one for spam:

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    ;; 'S' delete stuff in both search and show mode
    (define-key notmuch-show-mode-map "S"
      (lambda ()
        "Mark message as spam."
        (interactive)
        (notmuch-show-tag-all (list "+spam" "-inbox" "-unread" "-archive"))
        (notmuch-show-next-thread t)))
    (define-key notmuch-search-mode-map "S"
      (lambda ()
        "Mark message as spam."
        (interactive)
        (notmuch-search-tag (list "+spam" "-inbox" "-unread" "-archive"))
        (next-line))))
#+END_SRC

Custom actions allow us to define arbitrary commands to run on a message. We'll
use this to apply a mercurial patch to a working directory:

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch

    ;; adapted from http://emacs.stackexchange.com/questions/3485/how-do-i-maintain-a-history-of-ido-read-filenames
    (defun smf/patch-ido-read-directory-name (prompt)
      (cl-letf (((symbol-function 'orig-ido-read-internal)
                 (symbol-function 'ido-read-internal))
                ((symbol-function 'ido-read-internal)
                 (lambda (item prompt hist &optional default require-match initial)
                   (orig-ido-read-internal item prompt 'smf/patch-ido-directory-history
                                           default require-match initial))))
        (ido-read-directory-name prompt)))

    (defun smf/notmuch-show-import-patch ()
      "Import the hg patch."
      (interactive)
      (let* ((path (smf/patch-ido-read-directory-name "Target directory: "))
             (cmd (format "hg --cwd %s import -" path)))
        (notmuch-show-pipe-message nil cmd)))

    (define-key 'notmuch-show-mode-map "I" 'smf/notmuch-show-import-patch))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (defun smf/notmuch-show-view-as-patch ()
      "View the the current message as a patch."
      (interactive)
      (let* ((id (notmuch-show-get-message-id))
             (subject (concat "Subject: " (notmuch-show-get-subject) "\n"))
             (diff-default-read-only t)
             (buf (get-buffer-create (concat "*notmuch-patch-" id "*")))
             (part (notmuch-show-get-part-properties))
             (map (make-sparse-keymap)))
        (define-key map "q" 'notmuch-bury-or-kill-this-buffer)
        (switch-to-buffer buf)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert subject)
          (insert (plist-get part :content)))
        (set-buffer-modified-p nil)
        (diff-mode)
        (lexical-let ((new-ro-bind (cons 'buffer-read-only map)))
          (add-to-list 'minor-mode-overriding-map-alist new-ro-bind))
        (goto-char (point-min))))


    (define-key 'notmuch-show-mode-map "D" 'smf/notmuch-show-view-as-patch))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (after-load 'notmuch
    (defun smf/notmuch-show-set-pre-reviewed ()
      "Sets the patch in patchwork as pre-reviewed."
      (interactive)
      (let* ((msg-id (notmuch-show-get-message-id))
             (pw-cmd (expand-file-name "~/.pwclient"))
             (pw-id-list (process-lines pw-cmd "list"
                                        "-m" (concat "<" (s-chop-prefix "id:" msg-id) ">")
                                        "-n" "1"
                                        "-f" "%{id}"))
             (pw-id (nth 0 pw-id-list)))
        (message "Updating patchwork for patch %s" pw-id)
        (async-start-process "pwclient"
                             pw-cmd
                             (lambda (p)
                               (message "Marked patch as pre-reviewed"))
                             "update"
                             "-s" "Pre-Reviewed"
                             pw-id))))
#+END_SRC

*** Keybinding

Finally, add a keybinding to open our email client:

#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (require-package 's)
  (defun smf/notmuch-start-or-switch ()
    "Start the imapnotify process or switch to the notmuch buffer"
    (interactive)
    (with-current-buffer (get-buffer "*scratch*")
      (prodigy-start-service (prodigy-find-service "OfflineIMAP"))
      (notmuch)))

  (smf/add-launcher "e" 'smf/notmuch-start-or-switch)
#+END_SRC


** Local and custom configuration

*** Local overrides

So I can configure my Emacs per computer/user, I attempted to automatically load
some configuration.

First set up a directory to hold the files:

#+BEGIN_SRC emacs-lisp
  (setq smf/local-dotfiles-dir (smf/join-dirs smf/dotfiles-dir "local"))
#+END_SRC

Now try to load a file named after the current user:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir user-login-name ".el") t)
#+END_SRC

and try to load a file named after the local system:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir system-name ".el") t)
#+END_SRC

Finally, try loading a default file:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir "local-overrides.el") t)
#+END_SRC

*** =Customize=-d configuration

Make sure anything saved using =customize= goes into a consistent (and ignored)
place:

#+BEGIN_SRC emacs-lisp
  (load (setq custom-file (concat smf/dotfiles-dir "custom.el")) t)
#+END_SRC

(note that this works because =setq= returns the value it's set to)
