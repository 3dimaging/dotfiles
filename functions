# Create a new directory and enter it
unalias md 2>/dev/null
md() {
  mkdir -p "$@" && cd "$@"
}

# Easier navigation: .., ..., etc.
unalias .. 2>/dev/null
..() {
  eval cd ../\""$@"\"
}

_..() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ..* ]] || COMP_WORDS[COMP_CWORD]="../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b4- ) )
}
complete -o nospace -F _.. ..

unalias ... 2>/dev/null
...() {
  eval cd ../../\""$@"\"
}

_...() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ../..* ]] || COMP_WORDS[COMP_CWORD]="../../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b7- ) )
}
complete -o nospace -F _... ...

unalias .... 2>/dev/null
....() {
  eval cd ../../../\""$@"\"
}

_....() {
  [[ ${COMP_WORDS[COMP_CWORD]} == ../../..* ]] || COMP_WORDS[COMP_CWORD]="../../../${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -S '/' -d ${COMP_WORDS[COMP_CWORD]} -- ${COMP_WORDS[COMP_CWORD]} | cut -b9- ) )
}
complete -o nospace -F _.... ....

##################
# helper functions
##################

# usage: _not_in_list_exit $element $list
# return: echo "1" if found, "" if not found
_in_list() {
  local i
  local found=0

  for i in ${2//,/ }; do [[ "$i" == "$1" ]] && found=1; done

  [ $found -eq 1 ] && echo 1
}

# All the dig info
digga() {
  dig +nocmd "$1" any +multiline +noall +answer

}

pg() {
  [ -z "$@" ] && ps aux && return
  ps aux | grep -v grep | grep "$@"
}

kg() {
  [ -z "$@" ] && return
  local p line SUDO
  while read -r line; do
    SUDO=""
    p=($line)
    if [[ -n "${p[1]}" && ${p[1]} > 0 ]]; then
      [[ "$USER" != "${p[0]}" && "$(which sudo 2>/dev/null)" != "" ]] && SUDO=sudo
      $SUDO kill -9 ${p[1]}
      [ -z "$(ps ${p[1]} | grep -v PID)" ] && echo "Killed ${p[8]}|${p[1]}|${p[0]}|${p[10]}"
    fi
  done <<< "$(pg $@)"
}

d() {
  local i
  local GET="curl -OL"
  [[ -z "$(which curl 2>/dev/null)" ]] && GET="wget -c"

  for i in $@; do
    $GET $i;
  done;
}

ssh() {
  # system ssh command
  local SSH=$(which ssh)
  local SF=".emacs.d/server/server"
  local SFILE="$HOME/.emacs.d/server/server"
  [ -z "$DEBUG" ] || echo "[DEBUG] FILE: $SFILE"

  # read from emacs server file what port it is currently listening on
  local PORT=$(egrep  -o '127.0.0.1:([0-9]*)' "$SFILE" | sed 's/127.0.0.1://')
  [ -z "$DEBUG" ] || echo "[DEBUG] PORT: $PORT"

  # -t : allocate a tty so we are there.
  # -R : the remote port forward that lets emacsclient talk back
  # $@ : any other args this script was invoked with should be passed along.

  [ -z "$DEBUG" ] || echo "[DEBUG] SCP: copying $SFILE to $@:$SF"
  scp "$SFILE" "$@:$SF" &>/dev/null

  $SSH -t -R $PORT:127.0.0.1:$PORT $@
}

pd() {
  local i
  local d="${@%/}"
  if [ ! -z "$d" ]; then
    if [ ! -d "$d" ]; then
      for i in ${CDPATH//:/$'\n'}; do [ -d "$i/$d" ] && d="$i/$d"; done
    fi
    [ -d "$d" ] && export PETSC_DIR="$(readlink -f $d)" || echo "error: $d is not a directory"
  fi
  echo "$PETSC_DIR"
}
complete -o nospace -F _cd pd

pa() {
  if [[ -n "$@" && -x /opt/local/bin/port ]]; then
    export PETSC_ARCH="arch-${@%/}"

    [[ $PETSC_ARCH != *-opt* ]] && debug="+debug"
    [[ $PETSC_ARCH == *-64* ]] && long="+longindex"

    local variants="$debug$long"
    local mpi="$(mpi)"
    [[ $PETSC_ARCH == *-test* ]] && mpdeactivate $mpi && sudo port -q activate $mpi

    mpdeactivate $(port installed petsc* | grep active | perl -pe 's, \(active\),,')
  fi
  echo "$PETSC_ARCH"
}
complete -W "c c-64 c-fast c-opt complex cuda intel intel-opt test" pa

rmlog() {
  rm -rf CMake* *.log *.log.* *TAGS *.cache *.status $@
}
complete -A file rmlog

prm() {
  rm -rf arch* externalpackages && rmlog $@
}
complete -A file petsc-clean

pc() {
  printf "Configuring for PETSC_ARCH: "

  local i port
  local extra=""
  local arch=""
  for opt in $@; do
    [[ $opt == --* ]] && extra="$extra $opt" || arch="$opt"
  done

  local common_variants="netcdf,ml,hypre,metis,parmetis,blacs,scalapack,mumps,superlu,superlu_dist,sundials,suitesparse,fftw,yaml"

  # need to have map from variants to port names
  local common_ports="${common_variants//yaml/libyaml}"
  common_ports="${common_ports//fftw/fftw-3}"

  local common=""
  local active_ports=$(port installed ${common_ports//,/ } | grep active | perl -pe 's,^[\s]*,,')

  local OLD_IFS=$IFS
  IFS=$'\n';

  # for each active port, build the configure options
  for i in $active_ports; do
    port=$(echo $i | cut -d' ' -f1)
    case $port in
      fftw-3) common+=",fftw";;
      SuiteSparse) common+=",cholmod,umfpack";;
      *) common+=",$port";;
    esac
  done

  common=$(echo $common | perl -pe 's/^,//')

  IFS=$OLD_IFS

  pa $arch
  arch="$PETSC_ARCH"

  local libs="--with-shared-libraries --with-c++-support"
  local debug="--without-debugging"
  [[ $PETSC_ARCH != *opt* ]] && debug="--COPTFLAGS=-O0 --CXXOPTFLAGS=-O0 --FOPTFLAGS=-O0"

  if [[ $PETSC_ARCH == *-64* ]]; then
    common="metis,parmetis,superlu_dist,numdiff"
    libs="$libs --with-64-bit-indices"
  fi

  [[ $PETSC_ARCH == *-cuda* ]] && common+=",cusp" && libs+=" --with-thrust --with-cuda"

  libs="--with-{$common}-dir=/opt/local $libs $debug"
  [[ $PETSC_ARCH == *-test* ]] && libs=""

  eval ./configure $extra $libs
}

imsg() {
  if [ $# -lt 1 ]; then
    echo "Enter a iMessage account (email or phone number i.e +14156...) "
  fi

  local dbpath=$2
  [ -z "$dbpath" ] && dbpath="$HOME"

  sqlite3 $dbpath/Library/Messages/chat.db "select is_from_me,text,datetime(date + strftime('%s', '2001-01-01 00:00:00'),'unixepoch', 'localtime') as date from message" > MessageBackup.txt

  sqlite3 $dbpath/Library/Messages/chat.db "select filename from attachment" | cut -c 2- | awk -v home=$dbpath '{print home $0}' | tr '\n' '\0' | xargs -0 -t -I fname cp fname .
}

watchman-sync() {
  local wm=$(which watchman)
  [[ -z "$wm" ]] && echo "watchman executable not found!" && return 2

  local server="euclid"
  local project="$(basename $PWD)"
  local root="$(basename $(dirname $PWD))"

  # make sure we are in projects/foo
  [[ "$root" != "projects" ]] && echo "current working directory not recognized" && return 3

  # set remote server
  [[ -n "$1" ]] && server="$1"

  watchman -j<<-EOF
  [
  "trigger",
  "$PWD",
  {
    "name": "resync",
    "append_files": "false",
    "command": [
      "rsync",
      "-avhpI",
      "--checksum",
      "--exclude", "build",
      "--exclude", "hg.build",
      "--exclude", "*.so",
      "--exclude", "*.dll",
      "--exclude", "*.dSYM",
      "$PWD/",
      "euclid:$root/$project"
    ]
  }
  ]
EOF
}

change-mac-address() {
  openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//' | xargs sudo ifconfig en0 ether
}
