[ui]
username = Sean Farley <sean@mcs.anl.gov>
ssh = ssh -C
editor = emacs
ignore = ~/.hgignore

[extensions]
transplant =
purge =
color =
patchbomb =
parentrevspec =
schemes =
progress =
graphlog =
extdiff =
bookmarks =
mq =
rebase =
convert =
hgk =
record =
pager =
# Third-party extensions
hggit =
histedit =
hgsubversion =
crecord =

[schemes]
bb = ssh://hg@bitbucket.org/
me = ssh://hg@bitbucket.org/seanfarley/
gh = git+ssh://git@github.com/
petsc = ssh://petsc@petsc.cs.iit.edu//hg/petsc/

[diff]
git = True
unified = 5

[pager]
pager = LESS='FSRX' less

[hgattic]
trymerge = false

[extdiff]
cmd.fdiff = fmdiff
cmd.kdiff3 = kdiff3
cmd.vdiff = mvim
opts.vdiff = -c 'set lines=70' -c 'set columns=240' -f '+next' '+execute "DirDiff" argv(0) argv(1)'

cmd.sourcetreediff=opendiff
opts.sourcetreediff=
[merge-tools]
threesome.executable = mvim
threesome.args = -f $base $local $other $output -c 'ThreesomeInit'
threesome.premerge = keep
threesome.priority = 1

keepthat.executable = sh
keepthat.args = -c 'cp "$local" "$output.original" && cp "$other" "$output"'
keepthat.premerge = True

keepthis.executable = sh
keepthis.args = -c 'cp "$other" "$output.incoming" && cp "$local" "$output"'
keepthis.premerge = True

sourcetreemerge.gui=False
sourcetreebulkmerge.gui=False
sourcetreemerge.binary=False
sourcetreebulkmerge.executable=/Applications/SourceTree.app/Contents/Resources/hg-merge.sh
sourcetreemerge.args=$local $other -ancestor $base -merge $output
sourcetreemerge.checkconflicts=True
sourcetreemerge.premerge=True
sourcetreemerge.executable=/Applications/SourceTree.app/Contents/Resources/opendiff-w.sh
sourcetreebulkmerge.premerge=False
sourcetreebulkmerge.binary=True

[hostfingerprints]
bitbucket.org = 81:2b:08:90:dc:d3:71:ee:e0:7c:b4:75:ce:9b:6c:48:94:56:a1:fe

[email]
method = smtp
from = Sean Farley <sean@mcs.anl.gov>

[smtp]
host = smtp.gmail.com
port = 587
username = sean.michael.farley@gmail.com
tls = True

[color]
status.modified = cyan
status.added = green
status.removed = red
status.deleted = yellow bold underline
status.unknown = magenta bold underline
status.ignored = black bold
diff.diffline = none
diff.extended = cyan
diff.file_a = red
diff.file_b = green
diff.hunk = yellow bold
diff.deleted = red
diff.inserted = green
diff.changed = white
diff.trailingwhitespace = white_background
mq.qseries = white_background

[defaults]
rebase = --keepbranches
addremove = --similarity 100
pull = -u

[hooks]
commit = "$HG" dirty $@
post-rollback = "$HG" dirty $@
post-update = "$HG" dirty $@
post-attic-shelve = "$HG" dirty $@
post-attic-unshelve = "$HG" dirty $@

[alias]
# Show the url
url = showconfig paths.default

# Nudge: just push the current branch.
nudge = push --branch .

# Some useful little aliases.
st = status -SC
? = summary
df = diff

# Push the qparent revision (mnemonic: q push parent).
qpp = push -r qparent

# Merge with default.
md = merge default

# Commit message shortcuts.
cm = commit -m
cus = commit -m 'Update subrepository state.'
cuf = commit -m 'Update fixtures.' -I '**fixtures**.json'
cmm = commit -m 'Merge.'
cws = commit -m 'Whitespace.'

# Merge shortcuts.
mergelocal = !$HG --config ui.merge=internal:local merge $@
mergeother = !$HG --config ui.merge=internal:other merge $@
mergefail = !$HG --config ui.merge=internal:fail merge $@

# Shortcuts to resolve merge conflicts by taking one side or the other.
takelocal = !"$HG" revert --rev 'p1()' $@ && "$HG" resolve -m $@
takeother = !"$HG" revert --rev 'p2()' $@ && "$HG" resolve -m $@

# Run a colored diff and pipe it to less.
d = diff -p --pager=always

# Log shortcuts --------------------------------------------------------------------
#
# Each of these can be used with -v to add a bit more info.
nlog = log --pager=always --style=$HOME/.hgtemplates/map-cmdline.nlog

# hg n .     -- show a summary of rev . without diff.
# hg show .  -- show a summary of rev . with diff.
n = nlog -vr
show = nlog --color=always -vpr

# Simple glog command that doesn't look bad and doesn't require my CLI templates.
_gl = glog -l $1 -r ".~$1::." --template='\033[0;33m{node|short}\033[0m {desc|firstline|strip} \033[0;35m{branches}\033[0m \033[0;33m{tags}\033[0m\n\033[1;30m({date|age} by {author|person})\033[0m\n\n'
gl = !$HG _gl $(if [[ -z "$@" ]]; then echo 10; else echo "$@"; fi)

# Make a new repo with some sensible defaults.
mkrepo = !$HG init $1 && cd $1 && \
          echo 'syntax: glob'  > .hgignore && \
          echo ''             >> .hgignore && \
          echo '.DS_Store'    >> .hgignore && \
          echo '*.pyc'        >> .hgignore && \
          echo '*.swp'        >> .hgignore && \
          echo '*.swo'        >> .hgignore && \
          echo '*.un~'        >> .hgignore && \
          echo '.ropeproject' >> .hgignore && \
          echo 'tags'         >> .hgignore && \
          echo "[paths]\n" >> .hg/hgrc

# Edit the current repo's hgrc file.
rc = !$EDITOR `$HG root`/.hg/hgrc

# Easily add ignore patterns to .hgignore and commit.
ignore = ![ -n "$@" ] && echo '$@' >> `$HG root`/.hgignore && \
          $HG commit `$HG root`/.hgignore -Am 'Add "$@" to .hgignore.'

# Show in MacVim
vshow = !$HG show $@ | mvim -c ':AnsiEsc' -c 'setlocal buftype=nofile' -

# Run hg commands on all subrepos at once.
subs  = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | xargs    -n1  -I SUB $HG -R "`$HG root`/SUB" $@
psubs = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | parallel -j10 -I SUB $HG -R "`$HG root`/SUB" $@

# Run shell commands on all subrepos at once.
subscmd  = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | xargs    -n1  -I SUB sh -c "cd `$HG root`/SUB && $@"
psubscmd = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | parallel -j10 -I SUB sh -c "cd `$HG root`/SUB && $@"

# Run a command on a subrepo:
#
#     hg sub SUBREPO_REGEX ...command and arguments...
#
# The SUBREPO_REGEX should be a regex that will let grep match one and only one of
# the subrepos in .hgsub.  For example:
#
#     $ cat .hgsub
#     bundled/foo = ...
#     bundled/bar = ...
#
#     $ hg sub fo root
#     .../bundled/foo
#     $ hg sub ar status -m
#     M lol.py
sub = !grep = "`$HG root`/.hgsub" | cut -d' ' -f1 | grep "$1" | tr -d '\n ' | xargs -0 -I SUB $HG -R SUB $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $20

dirty = !if [[ ! -z "$($HG st -mardn $@)" ]]; then touch $($HG $@ root)/.hg/dirty; else rm -f $($HG $@ root)/.hg/dirty; fi

# pss for non-ignored files
pss = !$HG locate "set:not ignored()" | xargs pss $@
grep-wdir = !$HG locate "set:not ignored()" | xargs grep $@
egrep = !$HG locate -0 '$2' $3 $4 $5 $6 $7 $8 $9 | xargs -0 egrep -H '$1'
