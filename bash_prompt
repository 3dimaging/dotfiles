# @gf3’s Sexy Bash Prompt, inspired by "Extravagant Zsh Prompt"
# Shamelessly copied from https://github.com/gf3/dotfiles

# Powerline fonts from: https://github.com/Lokaltog/powerline-fonts
# On Mavericks, the powerline font was about 1px off, so followed:
# https://gist.github.com/qrush/1595572
# on the powerline-fontpatcher repo and settled on just using the y offset

# Helper functions are borrowed from liquidprompt:
# https://github.com/nojhan/liquidprompt

# exit if we terminal can't do colors
if [ ! -t 0 ] || [ "$TERM" == "dumb" ]; then
  return
fi

##
# colored highlighting is awesome
##

if [ "$TERM" != "dumb" -a -x "$(which dircolors 2>/dev/null)" ]; then
  eval "$(dircolors -b ~/.dir_colors)"
fi

MAGENTA=$(tput setaf 9)
GREEN=$(tput setaf 190)
PURPLE=$(tput setaf 5)
WHITE=$(tput setaf 240)
BLACK=$(tput setaf 0)
BOLD=$(tput bold)
RESET=$(tput sgr0)

# raw color numbers for hostname background and foreground
PURPLEBG=5
MAGENTABG=9
ORANGEBG=172
YELLOWBG=214
PINKBG=216
WHITEBG=230

PATHBG=$(tput setab 237)      # dark grey
PATHBGFG=$(tput setaf 237)
PATHFG=$(tput setaf 250)      # light grey
CWD_FG=$(tput setaf 254)      # nearly-white grey
SEP_FG=$(tput setaf 244)

CLEAN_BG=$(tput setab 148)    # a light green color
CLEAN_FG=$BLACK
DIRTY_BG=$(tput setab 161)    # pink/red
DIRTY_FG=$(tput setaf 15)     # white

PASSBG=$(tput setab 236)
PASSFG=$(tput setaf 15)
FAILBG=$(tput setab 161)
FAILFG=$(tput setaf 15)

HG="hg"
[ -n "$(which chg 2>/dev/null)" ] && HG="chg"

MD5="md5"
[ -n "$(which md5sum 2>/dev/null)" ] && MD5="md5sum"

COLORS=(
  $PURPLEBG
  $PINKBG
  $WHITEBG
  $YELLOWBG
  $MAGENTABG
  $YELLOWBG
  $MAGENTABG
  $WHITEBG
  $PINKBG
  $PURPLEBG
)

function pretty_dir () {
  # decent default values
  local max_len=27
  local mask=" … "
  local keep=2
  local ret=""
  local p=${PWD/#$HOME/"~"}

  if (( ${#p} <= ${max_len} )); then
    ret="$p"
  else
    local tmp=${path//\//}
    local -i delims=$(( ${#p} - ${#tmp} ))

    for (( dir=0; dir < ${keep}; dir++ )); do
      (( ${dir} == ${delims} )) && break

      local left="${p#*/}"
      local name="${p:0:${#p} - ${#left}}"
      p="${left}"
      ret="${ret}${name%/}/"
    done

    if (( ${delims} <= ${keep} )); then
      # no dirs between LP_PATH_KEEP leading dirs and current dir
      ret="${ret}${p##*/}"
    else
      local base="${p##*/}"

      p="${p:0:${#p} - ${#base}}"

      [[ ${ret} != "/" ]] && ret="${ret%/}" # strip trailing slash

      local -i len_left=$(( ${max_len} - ${#ret} - ${#base} - ${#mask} ))

      ret="${ret}${mask}${p:${#p} - ${len_left}}${base}"
    fi
  fi

  printf "${ret//\\/\\\\}"
}

# Search upwards through a directory structure looking for a file/folder with
# the given name.  Used to avoid invoking 'hg' and 'bzr'.
_lp_upwards_find()
{
    local dir
    dir="$PWD"
    while [[ -n "$dir" ]]; do
        [[ -d "$dir/$1" ]] && return 0
        dir="${dir%/*}"
    done
    return 1
}

function _lp_git_branch() {
  local gitdir
  gitdir="$([ $(\git ls-files . 2>/dev/null | wc -l) -gt 0 ] && \git rev-parse --git-dir 2>/dev/null)"
  [[ $? -ne 0 || ! $gitdir =~ (.*\/)?\.git.* ]] && return
  local branch
  # Recent versions of Git support the --short option for symbolic-ref, but
  # not 1.7.9 (Ubuntu 12.04)
  if branch="$(\git symbolic-ref -q HEAD)"; then
    printf "${branch#refs/heads/}"
  else
    # In detached head state, use commit instead
    # No escape needed
    \git rev-parse --short -q HEAD
  fi
}

# return 0 or 1 for dirty working directory
function _git_info() {
  _lp_upwards_find .git || return -1

  local br="$(_lp_git_branch)"
  local remote
  local st

  [ -n "$(\git stash list 2>/dev/null)" ] && br="$br+"

  st="$(git status 2> /dev/null)"
  remote="$(echo "$st" | perl -lne 'print " $2$1" if /Your branch is (ahead|behind).*?(\d+) comm/' | perl -pe 's,behind,⇣,' | perl -pe 's,ahead,⇡,')"
  st="$(echo "$st" | tail -1 | grep -v 'nothing to commit')"

  printf "$br$remote"

  [ -n "$st" ] && return 1
  return 0
}

# return 0 or 1 for dirty working directory
function _hg_info() {
  _lp_upwards_find .hg || return -1

  local br="$(fast-hg-bookmark 2>/dev/null)"
  local st="$($HG status 2>/dev/null)"
  local remote

  [ "$(echo "$st" | grep -c '\(^\?\)')" != "0" ] && br="$br*"
  [ -n "$($HG shelve -l 2>/dev/null)" ] && br="$br+"

  remote="$(fast-hg-remote | grep -v '+ 0' | egrep '^(\+|-)' | perl -pe 's,-\s?(\d+), \1⇣,' | perl -pe 's,\+\s?(\d+), \1⇡,')"

  printf "$br$remote"

  [ -n "$st" ] && return 1
  return 0
}

# note: unless the last portion of PS1 is a newline, then calling functions will have a
# problem as described here:
# http://stackoverflow.com/questions/6592077/bash-prompt-and-echoing-colors-inside-a-function
function update_ps1 () {
  # this function will build the PS1 string in-place as opposed to embedding bash
  # functions in the string due craziness with escape sequences as mentioned in the
  # stackoverflow link above
  local err=$?

  # only generate a hash color for non-local machines
  local host_color=$ORANGEBG
  if [[ "$(hostname)" != laptop.* ]]; then
    # generate a hash from the hostname
    local host_hash="$(hostname | $MD5)"

    # convert into a positive integer
    local host_number=$(( 0x${host_hash:4:6} % ${#COLORS[@]} ))
    [[ $host_number -lt 0 ]] && host_number=$(( -$host_number ))

    host_color=${COLORS[$host_number]}
  fi

  # note: these strings are chained from background color to foreground color so make
  # sure to check when rearranging
  local host="\[$(tput setab $host_color)\]\[$BOLD$BLACK\] $(hostname -s) \[$RESET\]"

  # creates a string with a shortened path
  local dir="$(pretty_dir)"
  # replace all the '/' with a fancy unicode separator
  dir="${dir//\//\\[$SEP_FG\\]  \\[$PATHFG\\]}"
  # hook into hostname color
  dir="\[$(tput setaf $host_color)$PATHBG\]\[$PATHBG$PATHFG\] $dir \[$PATHBGFG\]"

  # color repo depending on dirty working directory; must check here because we
  # need to set vcs type, status, etc. and it's annoying to deal with global
  # variables and subprocesses
  local bg=$CLEAN_BG
  local fg=$CLEAN_FG
  local repo
  local dirty
  local vcs_type

  repo="$(_git_info)"
  dirty=$?
  vcs_type="git"
  if [ -z "$repo" ]; then
    repo="$(_hg_info)"
    dirty="$?"
    vcs_type="hg"
    if [ -z "$repo" ]; then
      dirty=0
      vcs_type=""
    fi # nothing
  fi # hg

  # if repo found, plug it into the powerline chain
  if [ -n "$vcs_type" ]; then
    [ $dirty -eq 1 ] && bg=$DIRTY_BG && fg=$DIRTY_FG
    repo="\[$bg$PATHBGFG\]\[$fg\] $repo "
  fi

  local oldbg=$bg
  bg=$PASSBG
  fg=$PASSFG
  if [ $err -ne 0 ]; then
    bg=$FAILBG
    fg=$FAILFG
  fi

  # repo is empty so just match the path background and foreground
  if [ -z "$repo" ]; then
    repo="\[$bg${oldbg//48;/38;}$PATHBGFG\]"
  else
    repo="$repo\[$bg${oldbg//48;/38;}\]"
  fi

  # change the prompt mark depending on the repo type
  local mark="\$"
  case "$vcs_type" in
    git) mark="±";;
    hg) mark="☿";;
  esac

  # display previous bg color as fg color for arrow and new fg color for '$'
  local prompt="\[$bg$fg\] $mark "
  # the end cap which clears the background color and puts an arrow in the fg color of
  # the previous bg color
  oldbg=$bg
  local end="\[$RESET\]\[${oldbg//48;/38;}\]"

  export PS1="$host$dir$repo$prompt$end\[$RESET\]"
}

export PROMPT_COMMAND="update_ps1"
